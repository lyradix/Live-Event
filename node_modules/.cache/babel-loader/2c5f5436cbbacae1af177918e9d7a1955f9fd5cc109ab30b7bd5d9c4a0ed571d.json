{"ast":null,"code":"import QuickLRU from 'quick-lru';\nfunction tryGettingFetch() {\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n  return null;\n}\nclass ClientConfig {\n  constructor() {\n    /**\n     * MapTiler Cloud API key\n     */\n    this._apiKey = \"\";\n    /**\n     * The fetch function. To be set if in Node < 18, otherwise\n     * will be automatically resolved.\n     */\n    this._fetch = tryGettingFetch();\n    /**\n     * Number of tiles to keep in cache\n     */\n    this.tileCacheSize = 200;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    this._fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return this._fetch;\n  }\n}\nconst config = new ClientConfig();\nconst Language = {\n  /**\n   * Language mode to display the labels in the end user's device language.\n   */\n  AUTO: {\n    code: null,\n    flag: \"auto\",\n    name: \"Auto\",\n    latin: false,\n    isMode: true,\n    geocoding: true\n  },\n  /**\n   * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback. This is not to be confused with the \"Classical Latin\" language, which is available under the tag `.CLASSICAL_LATIN`.\n   */\n  LATIN: {\n    code: \"latin\",\n    flag: \"name:latin\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback.\n   */\n  NON_LATIN: {\n    code: \"nonlatin\",\n    flag: \"name:nonlatin\",\n    name: \"Non Latin\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.\n   */\n  LOCAL: {\n    code: null,\n    flag: \"name\",\n    name: \"Local\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Amharic language\n   */\n  AMHARIC: {\n    code: \"am\",\n    flag: \"name:am\",\n    name: \"Amharic\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Arabic language (right-to-left script)\n   */\n  ARABIC: {\n    code: \"ar\",\n    flag: \"name:ar\",\n    name: \"Arabic\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Azerbaijani language\n   */\n  AZERBAIJANI: {\n    code: \"az\",\n    flag: \"name:az\",\n    name: \"Azerbaijani\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Belarusian langauge\n   */\n  BELARUSIAN: {\n    code: \"be\",\n    flag: \"name:be\",\n    name: \"Belarusian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bulgarian language\n   */\n  BULGARIAN: {\n    code: \"bg\",\n    flag: \"bg\",\n    name: \"Bulgarian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bengali language\n   */\n  BENGALI: {\n    code: \"bn\",\n    flag: \"name:bn\",\n    name: \"Bengali\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Breton language\n   */\n  BRETON: {\n    code: \"br\",\n    flag: \"name:br\",\n    name: \"Breton\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bosnian language\n   */\n  BOSNIAN: {\n    code: \"bs\",\n    flag: \"name:bs\",\n    name: \"Bosnian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Catalan language\n   */\n  CATALAN: {\n    code: \"ca\",\n    flag: \"name:ca\",\n    name: \"Catalan\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Chinese language\n   */\n  CHINESE: {\n    code: \"zh\",\n    flag: \"name:zh\",\n    name: \"Chinese\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Traditional Chinese language\n   */\n  TRADITIONAL_CHINESE: {\n    code: \"zh-Hant\",\n    flag: \"name:zh-Hant\",\n    name: \"Chinese (traditional)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Simplified Chinese language\n   */\n  SIMPLIFIED_CHINESE: {\n    code: \"zh-Hans\",\n    flag: \"name:zh-Hans\",\n    name: \"Chinese (simplified)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Corsican language\n   */\n  CORSICAN: {\n    code: \"co\",\n    flag: \"name:co\",\n    name: \"Corsican\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Czech language\n   */\n  CZECH: {\n    code: \"cs\",\n    flag: \"name:cs\",\n    name: \"Czech\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Welsh language\n   */\n  WELSH: {\n    code: \"cy\",\n    flag: \"name:cy\",\n    name: \"WELSH\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Danish language\n   */\n  DANISH: {\n    code: \"da\",\n    flag: \"name:da\",\n    name: \"Danish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * German language\n   */\n  GERMAN: {\n    code: \"de\",\n    flag: \"name:de\",\n    name: \"German\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Greek language\n   */\n  GREEK: {\n    code: \"el\",\n    flag: \"name:el\",\n    name: \"Greek\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * English language\n   */\n  ENGLISH: {\n    code: \"en\",\n    flag: \"name:en\",\n    name: \"English\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Esperanto language\n   */\n  ESPERANTO: {\n    code: \"eo\",\n    flag: \"name:eo\",\n    name: \"Esperanto\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Spanish language\n   */\n  SPANISH: {\n    code: \"es\",\n    flag: \"name:es\",\n    name: \"Spanish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Estonian language\n   */\n  ESTONIAN: {\n    code: \"et\",\n    flag: \"name:et\",\n    name: \"Estonian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Basque language\n   */\n  BASQUE: {\n    code: \"eu\",\n    flag: \"name:eu\",\n    name: \"Basque\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Finnish language\n   */\n  FINNISH: {\n    code: \"fi\",\n    flag: \"name:fi\",\n    name: \"Finnish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * French language\n   */\n  FRENCH: {\n    code: \"fr\",\n    flag: \"name:fr\",\n    name: \"French\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Frisian language\n   */\n  FRISIAN: {\n    code: \"fy\",\n    flag: \"name:fy\",\n    name: \"Frisian (West)\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Irish language\n   */\n  IRISH: {\n    code: \"ga\",\n    flag: \"name:ga\",\n    name: \"Irish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Scottish Gaelic language\n   */\n  SCOTTISH_GAELIC: {\n    code: \"gd\",\n    flag: \"name:gd\",\n    name: \"Scottish Gaelic\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hebrew language (right-to-left non-latin script)\n   */\n  HEBREW: {\n    code: \"he\",\n    flag: \"name:he\",\n    name: \"Hebrew\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hindi language\n   */\n  HINDI: {\n    code: \"hi\",\n    flag: \"name:hi\",\n    name: \"Hindi\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Croatian language\n   */\n  CROATIAN: {\n    code: \"hr\",\n    flag: \"name:hr\",\n    name: \"Croatian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hungarian language\n   */\n  HUNGARIAN: {\n    code: \"hu\",\n    flag: \"name:hu\",\n    name: \"Hungarian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Armenian language\n   */\n  ARMENIAN: {\n    code: \"hy\",\n    flag: \"name:hy\",\n    name: \"Armenian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Indonesian language\n   */\n  INDONESIAN: {\n    code: \"id\",\n    flag: \"name:id\",\n    name: \"Indonesian\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Icelandic language\n   */\n  ICELANDIC: {\n    code: \"is\",\n    flag: \"name:is\",\n    name: \"Icelandic\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Italian language\n   */\n  ITALIAN: {\n    code: \"it\",\n    flag: \"name:it\",\n    name: \"Italian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Japanese language\n   */\n  JAPANESE: {\n    code: \"ja\",\n    flag: \"name:ja\",\n    name: \"Japanese\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Japanese language in Hiragana form\n   */\n  JAPANESE_HIRAGANA: {\n    code: \"ja-Hira\",\n    flag: \"name:ja-Hira\",\n    name: \"Japanese Hiragana form\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanese language (latin script)\n   */\n  JAPANESE_2018: {\n    code: \"ja-Latn\",\n    flag: \"name:ja-Latn\",\n    name: \"Japanese (Latin 2018)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanese language in Kana form (non-latin script)\n   */\n  JAPANESE_KANA: {\n    code: \"ja_kana\",\n    flag: \"name:ja_kana\",\n    name: \"Japanese (Kana)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanse language, romanized (latin script)\n   */\n  JAPANESE_LATIN: {\n    code: \"ja_rm\",\n    flag: \"name:ja_rm\",\n    name: \"Japanese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Georgian language\n   */\n  GEORGIAN: {\n    code: \"ka\",\n    flag: \"name:ka\",\n    name: \"Georgian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Kazakh language\n   */\n  KAZAKH: {\n    code: \"kk\",\n    flag: \"name:kk\",\n    name: \"Kazakh\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Kannada language\n   */\n  KANNADA: {\n    code: \"kn\",\n    flag: \"name:kn\",\n    name: \"Kannada\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Korean language\n   */\n  KOREAN: {\n    code: \"ko\",\n    flag: \"name:ko\",\n    name: \"Korean\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Korean language (latin script)\n   */\n  KOREAN_LATIN: {\n    code: \"ko-Latn\",\n    flag: \"name:ko-Latn\",\n    name: \"Korean (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Kurdish language\n   */\n  KURDISH: {\n    code: \"ku\",\n    flag: \"name:ku\",\n    name: \"Kurdish\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Classical Latin language\n   */\n  CLASSICAL_LATIN: {\n    code: \"la\",\n    flag: \"name:la\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Luxembourgish language\n   */\n  LUXEMBOURGISH: {\n    code: \"lb\",\n    flag: \"name:lb\",\n    name: \"Luxembourgish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Lithuanian language\n   */\n  LITHUANIAN: {\n    code: \"lt\",\n    flag: \"name:lt\",\n    name: \"Lithuanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Latvian language\n   */\n  LATVIAN: {\n    code: \"lv\",\n    flag: \"name:lv\",\n    name: \"Latvian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Macedonian language\n   */\n  MACEDONIAN: {\n    code: \"mk\",\n    flag: \"name:mk\",\n    name: \"Macedonian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Malayalm language\n   */\n  MALAYALAM: {\n    code: \"ml\",\n    flag: \"name:ml\",\n    name: \"Malayalam\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Maltese language\n   */\n  MALTESE: {\n    code: \"mt\",\n    flag: \"name:mt\",\n    name: \"Maltese\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Dutch language\n   */\n  DUTCH: {\n    code: \"nl\",\n    flag: \"name:nl\",\n    name: \"Dutch\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Norwegian language\n   */\n  NORWEGIAN: {\n    code: \"no\",\n    flag: \"name:no\",\n    name: \"Norwegian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Occitan language\n   */\n  OCCITAN: {\n    code: \"oc\",\n    flag: \"name:oc\",\n    name: \"Occitan\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Polish language\n   */\n  POLISH: {\n    code: \"pl\",\n    flag: \"name:pl\",\n    name: \"Polish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Persian language\n   */\n  PERSIAN: {\n    code: \"fa\",\n    flag: \"name:fa\",\n    name: \"Persian\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Punjabi language\n   */\n  PUNJABI: {\n    code: \"pa\",\n    flag: \"name:pa\",\n    name: \"Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Western Punjabi language\n   */\n  WESTERN_PUNJABI: {\n    code: \"pnb\",\n    flag: \"name:pnb\",\n    name: \"Western Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Portuguese language\n   */\n  PORTUGUESE: {\n    code: \"pt\",\n    flag: \"name:pt\",\n    name: \"Portuguese\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Romansh language\n   */\n  ROMANSH: {\n    code: \"rm\",\n    flag: \"name:rm\",\n    name: \"Romansh\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Romanian language\n   */\n  ROMANIAN: {\n    code: \"ro\",\n    flag: \"name:ro\",\n    name: \"Romanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Russian language\n   */\n  RUSSIAN: {\n    code: \"ru\",\n    flag: \"name:ru\",\n    name: \"Russian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Slovak language\n   */\n  SLOVAK: {\n    code: \"sk\",\n    flag: \"name:sk\",\n    name: \"Slovak\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Slovene language\n   */\n  SLOVENE: {\n    code: \"sl\",\n    flag: \"name:sl\",\n    name: \"Slovene\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Albanian language\n   */\n  ALBANIAN: {\n    code: \"sq\",\n    flag: \"name:sq\",\n    name: \"Albanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Serbian language (cyrillic script)\n   */\n  SERBIAN_CYRILLIC: {\n    code: \"sr\",\n    flag: \"name:sr\",\n    name: \"Serbian (Cyrillic script)\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Serbian language (latin script)\n   */\n  SERBIAN_LATIN: {\n    code: \"sr-Latn\",\n    flag: \"name:sr-Latn\",\n    name: \"Serbian (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Swedish language\n   */\n  SWEDISH: {\n    code: \"sv\",\n    flag: \"name:sv\",\n    name: \"Swedish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Tamil language\n   */\n  TAMIL: {\n    code: \"ta\",\n    flag: \"name:ta\",\n    name: \"Tamil\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Telugu language\n   */\n  TELUGU: {\n    code: \"te\",\n    flag: \"name:te\",\n    name: \"Telugu\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Thai language\n   */\n  THAI: {\n    code: \"th\",\n    flag: \"name:th\",\n    name: \"Thai\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Turkish language\n   */\n  TURKISH: {\n    code: \"tr\",\n    flag: \"name:tr\",\n    name: \"Turkish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Ukrainian language\n   */\n  UKRAINIAN: {\n    code: \"uk\",\n    flag: \"name:uk\",\n    name: \"Ukrainian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Vietnamese language (latin script)\n   */\n  VIETNAMESE: {\n    code: \"vi\",\n    flag: \"name:vi\",\n    name: \"Vietnamese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  }\n};\nfunction getLanguageInfoFromKey(languageKey, languageDictionnary = Language) {\n  if (languageKey in languageDictionnary) {\n    return languageKey[languageKey];\n  }\n  return null;\n}\nfunction getLanguageInfoFromCode(languageCode, languageDictionnary = Language) {\n  for (const lang of Object.values(languageDictionnary)) {\n    if (lang.code === languageCode) {\n      return lang;\n    }\n  }\n  return null;\n}\nfunction getLanguageInfoFromFlag(languageFlag, languageDictionnary = Language) {\n  for (const lang of Object.values(languageDictionnary)) {\n    if (lang.flag === languageFlag) {\n      return lang;\n    }\n  }\n  return null;\n}\nfunction getAutoLanguage() {\n  if (typeof navigator === \"undefined\") {\n    const code = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n    const langInfo = getLanguageInfoFromCode(code);\n    return langInfo ?? Language.ENGLISH;\n  }\n  const canditatelangs = Array.from(new Set(navigator.languages.map(l => l.split(\"-\")[0]))).map(code => getLanguageInfoFromCode(code)).filter(li => li);\n  return canditatelangs[0] ?? Language.ENGLISH;\n}\nfunction isLanguageInfo(obj) {\n  return obj !== null && typeof obj === \"object\" && \"code\" in obj && \"flag\" in obj && \"name\" in obj && \"latin\" in obj && \"isMode\" in obj && \"geocoding\" in obj && (typeof obj.code === \"string\" || obj.code === null) && typeof obj.flag === \"string\" && typeof obj.name === \"string\" && typeof obj.latin === \"boolean\" && typeof obj.isMode === \"boolean\" && typeof obj.geocoding === \"boolean\";\n}\nfunction toLanguageInfo(lang, languageDictionnary = Language) {\n  if (isLanguageInfo(lang)) {\n    return getLanguageInfoFromFlag(lang.flag, languageDictionnary);\n  }\n  if (typeof lang !== \"string\") {\n    return null;\n  }\n  return getLanguageInfoFromKey(lang, languageDictionnary) || getLanguageInfoFromCode(lang, languageDictionnary) || getLanguageInfoFromFlag(lang, languageDictionnary) || null;\n}\nfunction areSameLanguages(langA, langB, languageDictionnary = Language) {\n  const langAObj = toLanguageInfo(langA, languageDictionnary);\n  const langBObj = toLanguageInfo(langB, languageDictionnary);\n  return langAObj && langBObj && langAObj.flag === langBObj.flag;\n}\nasync function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\");\n  }\n  if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n    throw new Error(\"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\");\n  }\n  return config.fetch(resource, options);\n}\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\"\n};\nObject.freeze(defaults);\nclass ServiceError extends Error {\n  constructor(res, customMessage = \"\") {\n    super(`Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`);\n    this.res = res;\n  }\n}\nconst customMessages$4 = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction addLanguageGeocodingOptions(searchParams, options) {\n  const {\n    language\n  } = options;\n  if (language === void 0) {\n    return;\n  }\n  const languageCodes = (Array.isArray(language) ? language : [language]).map(elem => toValidGeocodingLanguageCode(elem)).filter(elem => elem);\n  const languages = Array.from(new Set(languageCodes)).join(\",\");\n  searchParams.set(\"language\", languages);\n}\nfunction toValidGeocodingLanguageCode(lang) {\n  let langInfo = null;\n  if (lang === Language.AUTO.flag) {\n    langInfo = getAutoLanguage();\n  } else if (typeof lang === \"string\") {\n    langInfo = getLanguageInfoFromCode(lang);\n  } else if (isLanguageInfo(lang)) {\n    langInfo = lang.flag === Language.AUTO.flag ? getAutoLanguage() : getLanguageInfoFromFlag(lang.flag);\n  }\n  if (!langInfo) return null;\n  if (langInfo.geocoding) return langInfo.code;\n  return null;\n}\nfunction addCommonForwardAndReverseGeocodingOptions(searchParams, options) {\n  const {\n    apiKey,\n    limit,\n    types,\n    excludeTypes\n  } = options;\n  searchParams.set(\"key\", apiKey ?? config.apiKey);\n  if (limit !== void 0) {\n    searchParams.set(\"limit\", String(limit));\n  }\n  if (types !== void 0) {\n    searchParams.set(\"types\", types.join(\",\"));\n  }\n  if (excludeTypes !== void 0) {\n    searchParams.set(\"excludeTypes\", String(excludeTypes));\n  }\n  addLanguageGeocodingOptions(searchParams, options);\n}\nfunction addForwardGeocodingOptions(searchParams, options) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n  const {\n    bbox,\n    proximity,\n    country,\n    fuzzyMatch,\n    autocomplete\n  } = options;\n  if (bbox !== void 0) {\n    searchParams.set(\"bbox\", bbox.join(\",\"));\n  }\n  if (proximity !== void 0) {\n    searchParams.set(\"proximity\", proximity === \"ip\" ? proximity : proximity.join(\",\"));\n  }\n  if (country !== void 0) {\n    searchParams.set(\"country\", country.join(\",\"));\n  }\n  if (fuzzyMatch !== void 0) {\n    searchParams.set(\"fuzzyMatch\", fuzzyMatch ? \"true\" : \"false\");\n  }\n  if (autocomplete !== void 0) {\n    searchParams.set(\"autocomplete\", autocomplete ? \"true\" : \"false\");\n  }\n}\nasync function forward(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(`geocoding/${encodeURIComponent(query)}.json`, defaults.maptilerApiURL);\n  const {\n    searchParams\n  } = endpoint;\n  addForwardGeocodingOptions(searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function reverse(position, options = {}) {\n  if (!Array.isArray(position) || position.length < 2) {\n    throw new Error(\"The position must be an array of form [lng, lat].\");\n  }\n  const endpoint = new URL(`geocoding/${position[0]},${position[1]}.json`, defaults.maptilerApiURL);\n  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function byId(id, options = {}) {\n  const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  addLanguageGeocodingOptions(endpoint.searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function batch$1(queries, options = {}) {\n  if (!queries.length) {\n    return [];\n  }\n  const joinedQuery = queries.map(query => encodeURIComponent(query)).join(\";\");\n  const endpoint = new URL(`geocoding/${joinedQuery}.json`, defaults.maptilerApiURL);\n  const {\n    searchParams\n  } = endpoint;\n  addForwardGeocodingOptions(searchParams, options);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return queries.length === 1 ? [obj] : obj;\n}\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch: batch$1\n};\nconst customMessages$3 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function info(options = {}) {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, res.status in customMessages$3 ? customMessages$3[res.status] : \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst geolocation = {\n  info\n};\nconst customMessages$2 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function search(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(`coordinates/search/${query}.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\"transformations\", options.transformations.toString());\n  }\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function transform(positions, options = {}) {\n  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map(coord => `${coord[0]},${coord[1]}`).join(\";\");\n  const endpoint = new URL(`coordinates/transform/${coordinatesStr}.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\"ops\", (Array.isArray(options.operations) ? options.operations : [options.operations]).join(\"|\"));\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst coordinates = {\n  search,\n  transform\n};\nconst customMessages$1 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function get(dataId, options = {}) {\n  if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n    throw new Error(\"The data ID must be a non-empty string\");\n  }\n  const endpoint = new URL(`data/${encodeURIComponent(dataId)}/features.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(res, res.status in customMessages$1 ? customMessages$1[res.status] : \"\");\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst data = {\n  get\n};\nfunction expandMapStyle(style) {\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n  return expandedStyle;\n}\nclass MapStyleVariant {\n  constructor(name, variantType, id, referenceStyle, description, imageURL) {\n    this.name = name;\n    this.variantType = variantType;\n    this.id = id;\n    this.referenceStyle = referenceStyle;\n    this.description = description;\n    this.imageURL = imageURL;\n  }\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  getFullName() {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType() {\n    return this.variantType;\n  }\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Get the human-friendly description\n   */\n  getDescription() {\n    return this.description;\n  }\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle() {\n    return this.referenceStyle;\n  }\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return this.referenceStyle.getVariant(variantType);\n  }\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants() {\n    return this.referenceStyle.getVariants().filter(v => v !== this);\n  }\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL() {\n    return this.imageURL;\n  }\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL() {\n    return expandMapStyle(this.getId());\n  }\n}\nclass ReferenceMapStyle {\n  constructor(name, id) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Variants that belong to this reference style, key being the reference type\n     */\n    this.variants = {};\n    /**\n     * Variants that belong to this reference style, ordered by relevance\n     */\n    this.orderedVariants = [];\n  }\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return variantType in this.variants;\n  }\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];\n  }\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants() {\n    return Object.values(this.variants);\n  }\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant() {\n    return this.orderedVariants[0];\n  }\n}\nconst mapStylePresetList = [{\n  referenceStyleID: \"STREETS\",\n  name: \"Streets\",\n  description: \"\",\n  variants: [{\n    id: \"streets-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-night\",\n    name: \"Night\",\n    variantType: \"NIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"streets-v2-pastel\",\n    name: \"Pastel\",\n    variantType: \"PASTEL\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"OUTDOOR\",\n  name: \"Outdoor\",\n  description: \"\",\n  variants: [{\n    id: \"outdoor-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"outdoor-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"WINTER\",\n  name: \"Winter\",\n  description: \"\",\n  variants: [{\n    id: \"winter-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"winter-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"SATELLITE\",\n  name: \"Satellite\",\n  description: \"\",\n  variants: [{\n    id: \"satellite\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"HYBRID\",\n  name: \"Hybrid\",\n  description: \"\",\n  variants: [{\n    id: \"hybrid\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"BASIC\",\n  name: \"Basic\",\n  description: \"\",\n  variants: [{\n    id: \"basic-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"basic-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"basic-v2-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"BRIGHT\",\n  name: \"Bright\",\n  description: \"\",\n  variants: [{\n    id: \"bright-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"bright-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"bright-v2-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"bright-v2-pastel\",\n    name: \"Pastel\",\n    variantType: \"PASTEL\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"OPENSTREETMAP\",\n  name: \"OpenStreetMap\",\n  description: \"\",\n  variants: [{\n    id: \"openstreetmap\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"TOPO\",\n  name: \"Topo\",\n  description: \"\",\n  variants: [{\n    id: \"topo-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-shiny\",\n    name: \"Shiny\",\n    variantType: \"SHINY\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-pastel\",\n    name: \"Pastel\",\n    variantType: \"PASTEL\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"topo-v2-topographique\",\n    name: \"Topographique\",\n    variantType: \"TOPOGRAPHIQUE\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"VOYAGER\",\n  name: \"Voyager\",\n  description: \"\",\n  variants: [{\n    id: \"voyager-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"voyager-v2-darkmatter\",\n    name: \"Darkmatter\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"voyager-v2-positron\",\n    name: \"Positron\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"voyager-v2-vintage\",\n    name: \"Vintage\",\n    variantType: \"VINTAGE\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"TONER\",\n  name: \"Toner\",\n  description: \"\",\n  variants: [{\n    id: \"toner-v2\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"toner-v2-background\",\n    name: \"Background\",\n    variantType: \"BACKGROUND\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"toner-v2-lite\",\n    name: \"Lite\",\n    variantType: \"LITE\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"toner-v2-lines\",\n    name: \"Lines\",\n    variantType: \"LINES\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"DATAVIZ\",\n  name: \"Dataviz\",\n  description: \"\",\n  variants: [{\n    id: \"dataviz\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"dataviz-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"dataviz-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"BACKDROP\",\n  name: \"Backdrop\",\n  description: \"\",\n  variants: [{\n    id: \"backdrop\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"backdrop-dark\",\n    name: \"Dark\",\n    variantType: \"DARK\",\n    description: \"\",\n    imageURL: \"\"\n  }, {\n    id: \"backdrop-light\",\n    name: \"Light\",\n    variantType: \"LIGHT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}, {\n  referenceStyleID: \"OCEAN\",\n  name: \"Ocean\",\n  description: \"\",\n  variants: [{\n    id: \"ocean\",\n    name: \"Default\",\n    variantType: \"DEFAULT\",\n    description: \"\",\n    imageURL: \"\"\n  }]\n}];\nfunction makeReferenceStyleProxy(referenceStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop)) {\n        return target.getVariant(prop);\n      }\n      if (prop.toString().toUpperCase() === prop) {\n        return referenceStyle.getDefaultVariant();\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction buildMapStyles() {\n  const mapStyle = {};\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n    const refStyle = makeReferenceStyleProxy(new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID));\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(variantInfo.name,\n      // name\n      variantInfo.variantType,\n      // variantType\n      variantInfo.id,\n      // id\n      refStyle,\n      // referenceStyle\n      variantInfo.description, variantInfo.imageURL\n      // imageURL\n      );\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle;\n}\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\nconst MapStyle = buildMapStyles();\nfunction extractLineStrings(geoJson) {\n  const lineStrings = [];\n  function extractFromGeometry(geometry) {\n    if (geometry.type === \"LineString\" || geometry.type === \"MultiLineString\") {\n      lineStrings.push(geometry);\n    }\n  }\n  function extractFromFeature(feature) {\n    if (feature.geometry) {\n      extractFromGeometry(feature.geometry);\n    }\n  }\n  function extractFromFeatureCollection(collection) {\n    for (const feature of collection.features) {\n      if (feature.type === \"Feature\") {\n        extractFromFeature(feature);\n      } else if (feature.type === \"FeatureCollection\") {\n        extractFromFeatureCollection(feature);\n      }\n    }\n  }\n  if (geoJson.type === \"Feature\") {\n    extractFromFeature(geoJson);\n  } else if (geoJson.type === \"FeatureCollection\") {\n    extractFromFeatureCollection(geoJson);\n  } else {\n    extractFromGeometry(geoJson);\n  }\n  return lineStrings;\n}\nfunction getSqSegDist(p, p1, p2) {\n  let x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  let maxSqDist = sqTolerance,\n    index;\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\nfunction simplify(points, tolerance) {\n  if (points.length <= 2) {\n    return points;\n  }\n  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\nconst misc = {\n  extractLineStrings,\n  simplify\n};\nfunction staticMapMarkerToString(marker, includeColor = true) {\n  let str = `${marker[0]},${marker[1]}`;\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n  return str;\n}\nfunction simplifyAndStringify(path, maxNbChar = 3e3) {\n  let str = path.map(point => point.join(\",\")).join(\"|\");\n  let tolerance = 5e-6;\n  const toleranceStep = 1e-5;\n  while (str.length > maxNbChar) {\n    const simplerPath = misc.simplify(path, tolerance);\n    str = simplerPath.map(point => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n  return str;\n}\nfunction centered(center, zoom, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map(m => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction bounded(boundingBox, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map(m => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction automatic(options = {}) {\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\"Automatic static maps require markers and/or path to be created.\");\n  }\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/auto/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map(m => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic\n};\nconst EARTH_RADIUS = 63710088e-1;\nconst EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;\nfunction longitudeToMercatorX(lng) {\n  return (180 + lng) / 360;\n}\nfunction latitudeToMercatorY(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nfunction wgs84ToMercator(position) {\n  const wrappedPos = wrapWgs84(position);\n  return [longitudeToMercatorX(wrappedPos[0]), latitudeToMercatorY(wrappedPos[1])];\n}\nfunction mercatorXToLongitude(x) {\n  return x * 360 - 180;\n}\nfunction mercatorYToLatitude(y) {\n  const y2 = 180 - y * 360;\n  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\nfunction mercatorToWgs84(position) {\n  return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];\n}\nfunction haversineDistanceWgs84(from, to) {\n  const rad = Math.PI / 180;\n  const lat1 = from[1] * rad;\n  const lat2 = to[1] * rad;\n  const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to[0] - from[0]) * rad);\n  const maxMeters = EARTH_RADIUS * Math.acos(Math.min(a, 1));\n  return maxMeters;\n}\nfunction haversineCumulatedDistanceWgs84(positions) {\n  const cumulatedDistance = Array(positions.length);\n  cumulatedDistance[0] = 0;\n  const l = cumulatedDistance.length;\n  for (let i = 1; i < l; i++) {\n    cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];\n  }\n  return cumulatedDistance;\n}\nfunction wrapWgs84(position) {\n  const lng = position[0];\n  const lat = position[1];\n  const d = 360;\n  const w = ((lng + 180) % d + d) % d - 180;\n  const wrapLong = w === -180 ? 180 : w;\n  return [wrapLong, lat];\n}\nfunction circumferenceAtLatitude(latitude) {\n  return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);\n}\nfunction mercatorToTileIndex(position, zoom, strict = true) {\n  const numberOfTilePerAxis = 2 ** zoom;\n  const fIndex = [position[0] * numberOfTilePerAxis, position[1] * numberOfTilePerAxis];\n  return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;\n}\nfunction wgs84ToTileIndex(position, zoom, strict = true) {\n  const merc = wgs84ToMercator(position);\n  return mercatorToTileIndex(merc, zoom, strict);\n}\nfunction toRadians(degrees) {\n  return degrees * Math.PI / 180;\n}\nfunction toDegrees(radians) {\n  return radians * 180 / Math.PI;\n}\nfunction haversineIntermediateWgs84(pos1, pos2, ratio) {\n  const d = haversineDistanceWgs84(pos1, pos2);\n  const 1 = toRadians(pos1[0]);\n  const 1 = toRadians(pos1[1]);\n  const 2 = toRadians(pos2[0]);\n  const 2 = toRadians(pos2[1]);\n  const  = d / EARTH_RADIUS;\n  const a = Math.sin((1 - ratio) * ) / Math.sin();\n  const b = Math.sin(ratio * ) / Math.sin();\n  const x = a * Math.cos(1) * Math.cos(1) + b * Math.cos(2) * Math.cos(2);\n  const y = a * Math.cos(1) * Math.sin(1) + b * Math.cos(2) * Math.sin(2);\n  const z = a * Math.sin(1) + b * Math.sin(2);\n  const 3 = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const 3 = Math.atan2(y, x);\n  return [toDegrees(3), toDegrees(3)];\n}\nconst math = {\n  EARTH_RADIUS,\n  EARTH_CIRCUMFERENCE,\n  longitudeToMercatorX,\n  latitudeToMercatorY,\n  wgs84ToMercator,\n  mercatorXToLongitude,\n  mercatorYToLatitude,\n  mercatorToWgs84,\n  haversineDistanceWgs84,\n  wrapWgs84,\n  circumferenceAtLatitude,\n  mercatorToTileIndex,\n  wgs84ToTileIndex,\n  toRadians,\n  toDegrees,\n  haversineIntermediateWgs84,\n  haversineCumulatedDistanceWgs84\n};\nlet tileCache = null;\nfunction getTileCache() {\n  if (!tileCache) {\n    tileCache = new QuickLRU({\n      maxSize: config.tileCacheSize\n    });\n  }\n  return tileCache;\n}\nasync function bufferToPixelDataBrowser(buff) {\n  const blob = new Blob([buff]);\n  const imageBitmap = await createImageBitmap(blob);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = imageBitmap.width;\n  canvas.height = imageBitmap.height;\n  ctx.drawImage(imageBitmap, 0, 0);\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  return {\n    pixels: imageData.data,\n    width: canvas.width,\n    height: canvas.height,\n    components: imageData.data.length / (canvas.width * canvas.height)\n  };\n}\nfunction getBufferToPixelDataParser() {\n  if (config.bufferToPixelData) {\n    return config.bufferToPixelData;\n  }\n  if (typeof window !== \"undefined\") {\n    return bufferToPixelDataBrowser;\n  }\n  throw new Error(\"An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`\");\n}\nconst terrainTileJsonURL = \"tiles/terrain-rgb-v2/tiles.json\";\nlet terrainTileJson = null;\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function fetchTerrainTileJson(apiKey) {\n  const endpoint = new URL(terrainTileJsonURL, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (res.ok) {\n    terrainTileJson = await res.json();\n    return terrainTileJson;\n  } else {\n    if (!res.ok) {\n      throw new ServiceError(res, customMessages[res.status] ?? \"\");\n    }\n  }\n}\nasync function at(position, options = {}) {\n  const apiKey = options.apiKey ?? config.apiKey;\n  if (!terrainTileJson) {\n    await fetchTerrainTileJson(apiKey);\n  }\n  const maxZoom = terrainTileJson.maxzoom;\n  let zoom = ~~(options.zoom ?? maxZoom);\n  if (zoom > maxZoom || zoom < 0) {\n    zoom = maxZoom;\n  }\n  const tileIndex = math.wgs84ToTileIndex(position, zoom, false);\n  const tileX = ~~tileIndex[0];\n  const tileY = ~~tileIndex[1];\n  if (!terrainTileJson.tiles.length) {\n    throw new Error(\"Terrain tileJSON tile list is empty.\");\n  }\n  const tileID = `terrain_${zoom.toString()}_${tileX.toString()}_${tileY.toString()}`;\n  let tilePixelData;\n  const cache = getTileCache();\n  if (cache.has(tileID)) {\n    tilePixelData = cache.get(tileID);\n  } else {\n    const tileURL = terrainTileJson.tiles[0].replace(\"{x}\", tileX.toString()).replace(\"{y}\", tileY.toString()).replace(\"{z}\", zoom.toString());\n    const tileRes = await callFetch(tileURL);\n    if (!tileRes.ok) {\n      throw new ServiceError(tileRes, customMessages[tileRes.status] ?? \"\");\n    }\n    const tileBuff = await tileRes.arrayBuffer();\n    const tileParser = getBufferToPixelDataParser();\n    tilePixelData = await tileParser(tileBuff);\n    cache.set(tileID, tilePixelData);\n  }\n  const pixelX = ~~(tilePixelData.width * (tileIndex[0] % 1));\n  const pixelY = ~~(tilePixelData.height * (tileIndex[1] % 1));\n  const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n  const R = tilePixelData.pixels[pixelDataIndex];\n  const G = tilePixelData.pixels[pixelDataIndex + 1];\n  const B = tilePixelData.pixels[pixelDataIndex + 2];\n  const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;\n  return [position[0], position[1], elevation2];\n}\nasync function batch(positions, options = {}) {\n  const apiKey = options.apiKey ?? config.apiKey;\n  if (!terrainTileJson) {\n    await fetchTerrainTileJson(apiKey);\n  }\n  const tileParser = getBufferToPixelDataParser();\n  const tileURLSchema = terrainTileJson.tiles[0];\n  const cache = getTileCache();\n  const maxZoom = terrainTileJson.maxzoom;\n  let zoom = ~~(options.zoom ?? maxZoom);\n  if (zoom > maxZoom || zoom < 0) {\n    zoom = maxZoom;\n  }\n  const tileIndicesFloats = positions.map(position => math.wgs84ToTileIndex(position, zoom, false));\n  const tileIndicesInteger = tileIndicesFloats.map(index => [~~index[0], ~~index[1]]);\n  const tileIDs = tileIndicesInteger.map(index => `terrain_${zoom.toString()}_${index[0].toString()}_${index[1].toString()}`);\n  const uniqueTilesToFetch = Array.from(new Set(tileIDs.filter(tileID => !cache.has(tileID)))).map(tileID => tileID.split(\"_\").slice(1));\n  const tileURLs = uniqueTilesToFetch.map(zxy => tileURLSchema.replace(\"{x}\", zxy[1].toString()).replace(\"{y}\", zxy[2].toString()).replace(\"{z}\", zxy[0].toString()));\n  const promisesFetchTiles = tileURLs.map(url => callFetch(url));\n  const resTiles = await Promise.allSettled(promisesFetchTiles);\n  const fulfilledRes = resTiles.map(el => el.status === \"fulfilled\" ? el.value : null).filter(res => res);\n  const fulfilledRButNotOkRes = fulfilledRes.filter(res => !res.ok);\n  if (fulfilledRes.length !== promisesFetchTiles.length) {\n    throw new Error(\"Some tiles could not be fetched.\");\n  }\n  if (fulfilledRButNotOkRes.length) {\n    throw new ServiceError(fulfilledRButNotOkRes[0], customMessages[fulfilledRButNotOkRes[0].status] ?? \"\");\n  }\n  const tileArrayBuffers = await Promise.all(fulfilledRes.map(res => res.arrayBuffer()));\n  if (!tileArrayBuffers.every(buff => buff.byteLength > 0)) {\n    throw new Error(\"Some tiles are not available.\");\n  }\n  const tilePixelDatas = await Promise.all(tileArrayBuffers.map(buff => tileParser(buff)));\n  tilePixelDatas.forEach((tilePixelData, i) => {\n    const zxy = uniqueTilesToFetch[i];\n    const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;\n    cache.set(tileID, tilePixelData);\n  });\n  const elevatedPositions = positions.map((position, i) => {\n    const tileID = tileIDs[i];\n    const tileIndexFloat = tileIndicesFloats[i];\n    const tilePixelData = cache.get(tileID);\n    const pixelX = Math.min(Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)), tilePixelData.width - 1);\n    const pixelY = Math.min(Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)), tilePixelData.height - 1);\n    const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n    const R = tilePixelData.pixels[pixelDataIndex];\n    const G = tilePixelData.pixels[pixelDataIndex + 1];\n    const B = tilePixelData.pixels[pixelDataIndex + 2];\n    const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;\n    return [position[0], position[1], ~~(elevation2 * 1e3) / 1e3];\n  });\n  if (options.smoothingKernelSize) {\n    const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;\n    const elevations = elevatedPositions.map(pos => pos[2]);\n    const kernelSpan = ~~(kernelSize / 2);\n    for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {\n      let sum = 0;\n      for (let j = 0; j < kernelSize; j += 1) {\n        const elev = elevations[i - kernelSpan + j];\n        sum += elev;\n      }\n      sum /= kernelSize;\n      elevatedPositions[i][2] = sum;\n    }\n  }\n  return elevatedPositions;\n}\nasync function fromLineString(ls, options = {}) {\n  if (ls.type !== \"LineString\") {\n    throw new Error(\"The provided object is not a GeoJSON LineString\");\n  }\n  const clone = structuredClone(ls);\n  const elevatedPositions = await batch(clone.coordinates, options);\n  clone.coordinates = elevatedPositions;\n  return clone;\n}\nasync function fromMultiLineString(ls, options = {}) {\n  if (ls.type !== \"MultiLineString\") {\n    throw new Error(\"The provided object is not a GeoJSON MultiLineString\");\n  }\n  const clone = structuredClone(ls);\n  const multiLengths = clone.coordinates.map(poss => poss.length);\n  const flattenPositions = clone.coordinates.flat();\n  const flattenPositionsElevated = await batch(flattenPositions, options);\n  const result = [];\n  let index = 0;\n  for (const length of multiLengths) {\n    result.push(flattenPositionsElevated.slice(index, index + length));\n    index += length;\n  }\n  clone.coordinates = result;\n  return clone;\n}\nconst elevation = {\n  at,\n  batch,\n  fromLineString,\n  fromMultiLineString\n};\nexport { ClientConfig, Language, MapStyle, MapStyleVariant, ReferenceMapStyle, ServiceError, areSameLanguages, bufferToPixelDataBrowser, circumferenceAtLatitude, config, coordinates, data, elevation, expandMapStyle, geocoding, geolocation, getAutoLanguage, getBufferToPixelDataParser, getLanguageInfoFromCode, getLanguageInfoFromFlag, getLanguageInfoFromKey, getTileCache, isLanguageInfo, mapStylePresetList, math, misc, staticMaps, styleToStyle, toLanguageInfo };","map":{"version":3,"names":["tryGettingFetch","self","fetch","bind","global","ClientConfig","constructor","_apiKey","_fetch","tileCacheSize","apiKey","k","f","config","Language","AUTO","code","flag","name","latin","isMode","geocoding","LATIN","NON_LATIN","LOCAL","AMHARIC","ARABIC","AZERBAIJANI","BELARUSIAN","BULGARIAN","BENGALI","BRETON","BOSNIAN","CATALAN","CHINESE","TRADITIONAL_CHINESE","SIMPLIFIED_CHINESE","CORSICAN","CZECH","WELSH","DANISH","GERMAN","GREEK","ENGLISH","ESPERANTO","SPANISH","ESTONIAN","BASQUE","FINNISH","FRENCH","FRISIAN","IRISH","SCOTTISH_GAELIC","HEBREW","HINDI","CROATIAN","HUNGARIAN","ARMENIAN","INDONESIAN","ICELANDIC","ITALIAN","JAPANESE","JAPANESE_HIRAGANA","JAPANESE_2018","JAPANESE_KANA","JAPANESE_LATIN","GEORGIAN","KAZAKH","KANNADA","KOREAN","KOREAN_LATIN","KURDISH","CLASSICAL_LATIN","LUXEMBOURGISH","LITHUANIAN","LATVIAN","MACEDONIAN","MALAYALAM","MALTESE","DUTCH","NORWEGIAN","OCCITAN","POLISH","PERSIAN","PUNJABI","WESTERN_PUNJABI","PORTUGUESE","ROMANSH","ROMANIAN","RUSSIAN","SLOVAK","SLOVENE","ALBANIAN","SERBIAN_CYRILLIC","SERBIAN_LATIN","SWEDISH","TAMIL","TELUGU","THAI","TURKISH","UKRAINIAN","VIETNAMESE","getLanguageInfoFromKey","languageKey","languageDictionnary","getLanguageInfoFromCode","languageCode","lang","Object","values","getLanguageInfoFromFlag","languageFlag","getAutoLanguage","navigator","Intl","DateTimeFormat","resolvedOptions","locale","split","langInfo","canditatelangs","Array","from","Set","languages","map","l","filter","li","isLanguageInfo","obj","toLanguageInfo","areSameLanguages","langA","langB","langAObj","langBObj","callFetch","resource","options","Error","URL","searchParams","get","trim","defaults","maptilerApiURL","mapStyle","freeze","ServiceError","res","customMessage","url","status","customMessages$4","addLanguageGeocodingOptions","language","languageCodes","isArray","elem","toValidGeocodingLanguageCode","join","set","addCommonForwardAndReverseGeocodingOptions","limit","types","excludeTypes","String","addForwardGeocodingOptions","bbox","proximity","country","fuzzyMatch","autocomplete","forward","query","length","endpoint","encodeURIComponent","urlWithParams","toString","ok","json","reverse","position","byId","id","batch$1","batch","queries","joinedQuery","customMessages$3","info","geolocation","customMessages$2","search","transformations","exports","transform","positions","coordinatesStr","coord","sourceCrs","targetCrs","operations","coordinates","customMessages$1","dataId","data","expandMapStyle","style","maptilerDomainRegex","match","trimmed","expandedStyle","startsWith","exec","MapStyleVariant","variantType","referenceStyle","description","imageURL","getName","getFullName","getType","getId","getDescription","getReferenceStyle","hasVariant","getVariant","getVariants","v","getImageURL","getExpandedStyleURL","ReferenceMapStyle","variants","orderedVariants","addVariant","push","getDefaultVariant","mapStylePresetList","referenceStyleID","makeReferenceStyleProxy","Proxy","target","prop","receiver","toUpperCase","Reflect","buildMapStyles","i","refStyleInfo","refStyle","j","variantInfo","variant","styleToStyle","MapStyle","toLowerCase","extractLineStrings","geoJson","lineStrings","extractFromGeometry","geometry","type","extractFromFeature","feature","extractFromFeatureCollection","collection","features","getSqSegDist","p","p1","p2","x","y","dx","dy","t","simplifyDPStep","points","first","last","sqTolerance","simplified","maxSqDist","index","sqDist","simplifyDouglasPeucker","simplify","tolerance","simplePoints","misc","staticMapMarkerToString","marker","includeColor","str","simplifyAndStringify","path","maxNbChar","point","toleranceStep","simplerPath","centered","center","zoom","scale","hiDPI","format","width","height","attribution","markerStr","hasIcon","markerIcon","markerAnchor","markerList","markers","m","pathStr","pathFillColor","pathStrokeColor","pathWidth","bounded","boundingBox","padding","automatic","staticMaps","EARTH_RADIUS","EARTH_CIRCUMFERENCE","Math","PI","longitudeToMercatorX","lng","latitudeToMercatorY","lat","log","tan","wgs84ToMercator","wrappedPos","wrapWgs84","mercatorXToLongitude","mercatorYToLatitude","y2","atan","exp","mercatorToWgs84","haversineDistanceWgs84","to","rad","lat1","lat2","a","sin","cos","maxMeters","acos","min","haversineCumulatedDistanceWgs84","cumulatedDistance","d","w","wrapLong","circumferenceAtLatitude","latitude","mercatorToTileIndex","strict","numberOfTilePerAxis","fIndex","wgs84ToTileIndex","merc","toRadians","degrees","toDegrees","radians","haversineIntermediateWgs84","pos1","pos2","ratio","1","1","2","2","","b","z","3","atan2","sqrt","3","math","tileCache","getTileCache","QuickLRU","maxSize","bufferToPixelDataBrowser","buff","blob","Blob","imageBitmap","createImageBitmap","canvas","document","createElement","ctx","getContext","drawImage","imageData","getImageData","pixels","components","getBufferToPixelDataParser","bufferToPixelData","window","terrainTileJsonURL","terrainTileJson","customMessages","fetchTerrainTileJson","at","maxZoom","maxzoom","tileIndex","tileX","tileY","tiles","tileID","tilePixelData","cache","has","tileURL","replace","tileRes","tileBuff","arrayBuffer","tileParser","pixelX","pixelY","pixelDataIndex","R","G","B","elevation2","tileURLSchema","tileIndicesFloats","tileIndicesInteger","tileIDs","uniqueTilesToFetch","slice","tileURLs","zxy","promisesFetchTiles","resTiles","Promise","allSettled","fulfilledRes","el","value","fulfilledRButNotOkRes","tileArrayBuffers","all","every","byteLength","tilePixelDatas","forEach","elevatedPositions","tileIndexFloat","round","smoothingKernelSize","kernelSize","elevations","pos","kernelSpan","sum","elev","fromLineString","ls","clone","structuredClone","fromMultiLineString","multiLengths","poss","flattenPositions","flat","flattenPositionsElevated","result","elevation"],"sources":["C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\config.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\language.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\callFetch.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\defaults.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\ServiceError.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\geocoding.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\geolocation.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\coordinates.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\data.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\mapstyle.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\misc.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\staticMaps.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\math.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\tiledecoding.ts","C:\\Users\\daryl\\source\\repos\\Live-Event\\live-event\\node_modules\\@maptiler\\client\\src\\services\\elevation.ts"],"sourcesContent":["import { BufferToPixelDataFunction } from \"./tiledecoding\";\n\nexport type FetchFunction = (\n  input: RequestInfo | URL,\n  init?: RequestInit,\n) => Promise<Response>;\n\nfunction tryGettingFetch() {\n  // this is browser, fetch exists\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n\n  return null;\n}\n\n/**\n * The configuration object definition\n */\nclass ClientConfig {\n  /**\n   * MapTiler Cloud API key\n   */\n  private _apiKey = \"\";\n\n  /**\n   * The fetch function. To be set if in Node < 18, otherwise\n   * will be automatically resolved.\n   */\n  private _fetch: FetchFunction | null = tryGettingFetch();\n\n  /**\n   * Number of tiles to keep in cache\n   */\n  public tileCacheSize: number = 200;\n\n  public bufferToPixelData: BufferToPixelDataFunction | null;\n\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k: string) {\n    this._apiKey = k;\n  }\n\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey(): string {\n    return this._apiKey;\n  }\n\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f: FetchFunction) {\n    this._fetch = f;\n  }\n\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch(): FetchFunction | null {\n    return this._fetch;\n  }\n}\n\n/**\n * Configuration object\n */\nconst config = new ClientConfig();\n\nexport { ClientConfig, config };\n","export type LanguageInfo = {\n  /**\n   * Two letter ISO code, such as `\"en\"` for English language.\n   * Can be `null` if the language is a flag to be evaluated at runtime,\n   * as it is the case for some \"modes\".\n   */\n  code: string | null;\n\n  /**\n   * The full OSM language flag, such as `\"name:en\"` for the English language.\n   * Can also be a non-OSM flag if the language needs to be evaluated at runtime, such as `\"auto\"`,\n   * as it is the case for some \"modes\".\n   */\n  flag: string;\n\n  /**\n   * English name of the language.\n   */\n  name: string;\n\n  /**\n   * Whether the language leverages only the latin charsets.\n   */\n  latin: boolean;\n\n  /**\n   * Some language descriptions corresponds to \"modes\" rather than to actual languages.\n   * For instance the \"visitor\" mode consists in displaying bylingual labels.\n   */\n  isMode: boolean;\n\n  /**\n   * Whether the language is compatible with the geocoding API\n   */\n  geocoding: boolean;\n};\n\n/**\n * The complete list of languages\n */\nexport const Language = {\n  /**\n   * Language mode to display the labels in the end user's device language.\n   */\n  AUTO: {\n    code: null,\n    flag: \"auto\",\n    name: \"Auto\",\n    latin: false,\n    isMode: true,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback. This is not to be confused with the \"Classical Latin\" language, which is available under the tag `.CLASSICAL_LATIN`.\n   */\n  LATIN: {\n    code: \"latin\",\n    flag: \"name:latin\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback.\n   */\n  NON_LATIN: {\n    code: \"nonlatin\",\n    flag: \"name:nonlatin\",\n    name: \"Non Latin\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.\n   */\n  LOCAL: {\n    code: null,\n    flag: \"name\",\n    name: \"Local\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Amharic language\n   */\n  AMHARIC: {\n    code: \"am\",\n    flag: \"name:am\",\n    name: \"Amharic\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Arabic language (right-to-left script)\n   */\n  ARABIC: {\n    code: \"ar\",\n    flag: \"name:ar\",\n    name: \"Arabic\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Azerbaijani language\n   */\n  AZERBAIJANI: {\n    code: \"az\",\n    flag: \"name:az\",\n    name: \"Azerbaijani\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Belarusian langauge\n   */\n  BELARUSIAN: {\n    code: \"be\",\n    flag: \"name:be\",\n    name: \"Belarusian\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Bulgarian language\n   */\n  BULGARIAN: {\n    code: \"bg\",\n    flag: \"bg\",\n    name: \"Bulgarian\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Bengali language\n   */\n  BENGALI: {\n    code: \"bn\",\n    flag: \"name:bn\",\n    name: \"Bengali\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Breton language\n   */\n  BRETON: {\n    code: \"br\",\n    flag: \"name:br\",\n    name: \"Breton\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Bosnian language\n   */\n  BOSNIAN: {\n    code: \"bs\",\n    flag: \"name:bs\",\n    name: \"Bosnian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Catalan language\n   */\n  CATALAN: {\n    code: \"ca\",\n    flag: \"name:ca\",\n    name: \"Catalan\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Chinese language\n   */\n  CHINESE: {\n    code: \"zh\",\n    flag: \"name:zh\",\n    name: \"Chinese\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Traditional Chinese language\n   */\n  TRADITIONAL_CHINESE: {\n    code: \"zh-Hant\",\n    flag: \"name:zh-Hant\",\n    name: \"Chinese (traditional)\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Simplified Chinese language\n   */\n  SIMPLIFIED_CHINESE: {\n    code: \"zh-Hans\",\n    flag: \"name:zh-Hans\",\n    name: \"Chinese (simplified)\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Corsican language\n   */\n  CORSICAN: {\n    code: \"co\",\n    flag: \"name:co\",\n    name: \"Corsican\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Czech language\n   */\n  CZECH: {\n    code: \"cs\",\n    flag: \"name:cs\",\n    name: \"Czech\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Welsh language\n   */\n  WELSH: {\n    code: \"cy\",\n    flag: \"name:cy\",\n    name: \"WELSH\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Danish language\n   */\n  DANISH: {\n    code: \"da\",\n    flag: \"name:da\",\n    name: \"Danish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * German language\n   */\n  GERMAN: {\n    code: \"de\",\n    flag: \"name:de\",\n    name: \"German\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Greek language\n   */\n  GREEK: {\n    code: \"el\",\n    flag: \"name:el\",\n    name: \"Greek\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * English language\n   */\n  ENGLISH: {\n    code: \"en\",\n    flag: \"name:en\",\n    name: \"English\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Esperanto language\n   */\n  ESPERANTO: {\n    code: \"eo\",\n    flag: \"name:eo\",\n    name: \"Esperanto\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Spanish language\n   */\n  SPANISH: {\n    code: \"es\",\n    flag: \"name:es\",\n    name: \"Spanish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Estonian language\n   */\n  ESTONIAN: {\n    code: \"et\",\n    flag: \"name:et\",\n    name: \"Estonian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Basque language\n   */\n  BASQUE: {\n    code: \"eu\",\n    flag: \"name:eu\",\n    name: \"Basque\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Finnish language\n   */\n  FINNISH: {\n    code: \"fi\",\n    flag: \"name:fi\",\n    name: \"Finnish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * French language\n   */\n  FRENCH: {\n    code: \"fr\",\n    flag: \"name:fr\",\n    name: \"French\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Frisian language\n   */\n  FRISIAN: {\n    code: \"fy\",\n    flag: \"name:fy\",\n    name: \"Frisian (West)\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Irish language\n   */\n  IRISH: {\n    code: \"ga\",\n    flag: \"name:ga\",\n    name: \"Irish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Scottish Gaelic language\n   */\n  SCOTTISH_GAELIC: {\n    code: \"gd\",\n    flag: \"name:gd\",\n    name: \"Scottish Gaelic\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Hebrew language (right-to-left non-latin script)\n   */\n  HEBREW: {\n    code: \"he\",\n    flag: \"name:he\",\n    name: \"Hebrew\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Hindi language\n   */\n  HINDI: {\n    code: \"hi\",\n    flag: \"name:hi\",\n    name: \"Hindi\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Croatian language\n   */\n  CROATIAN: {\n    code: \"hr\",\n    flag: \"name:hr\",\n    name: \"Croatian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Hungarian language\n   */\n  HUNGARIAN: {\n    code: \"hu\",\n    flag: \"name:hu\",\n    name: \"Hungarian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Armenian language\n   */\n  ARMENIAN: {\n    code: \"hy\",\n    flag: \"name:hy\",\n    name: \"Armenian\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Indonesian language\n   */\n  INDONESIAN: {\n    code: \"id\",\n    flag: \"name:id\",\n    name: \"Indonesian\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Icelandic language\n   */\n  ICELANDIC: {\n    code: \"is\",\n    flag: \"name:is\",\n    name: \"Icelandic\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Italian language\n   */\n  ITALIAN: {\n    code: \"it\",\n    flag: \"name:it\",\n    name: \"Italian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Japanese language\n   */\n  JAPANESE: {\n    code: \"ja\",\n    flag: \"name:ja\",\n    name: \"Japanese\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Japanese language in Hiragana form\n   */\n  JAPANESE_HIRAGANA: {\n    code: \"ja-Hira\",\n    flag: \"name:ja-Hira\",\n    name: \"Japanese Hiragana form\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Japanese language (latin script)\n   */\n  JAPANESE_2018: {\n    code: \"ja-Latn\",\n    flag: \"name:ja-Latn\",\n    name: \"Japanese (Latin 2018)\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Japanese language in Kana form (non-latin script)\n   */\n  JAPANESE_KANA: {\n    code: \"ja_kana\",\n    flag: \"name:ja_kana\",\n    name: \"Japanese (Kana)\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Japanse language, romanized (latin script)\n   */\n  JAPANESE_LATIN: {\n    code: \"ja_rm\",\n    flag: \"name:ja_rm\",\n    name: \"Japanese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Georgian language\n   */\n  GEORGIAN: {\n    code: \"ka\",\n    flag: \"name:ka\",\n    name: \"Georgian\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Kazakh language\n   */\n  KAZAKH: {\n    code: \"kk\",\n    flag: \"name:kk\",\n    name: \"Kazakh\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Kannada language\n   */\n  KANNADA: {\n    code: \"kn\",\n    flag: \"name:kn\",\n    name: \"Kannada\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Korean language\n   */\n  KOREAN: {\n    code: \"ko\",\n    flag: \"name:ko\",\n    name: \"Korean\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Korean language (latin script)\n   */\n  KOREAN_LATIN: {\n    code: \"ko-Latn\",\n    flag: \"name:ko-Latn\",\n    name: \"Korean (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Kurdish language\n   */\n  KURDISH: {\n    code: \"ku\",\n    flag: \"name:ku\",\n    name: \"Kurdish\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Classical Latin language\n   */\n  CLASSICAL_LATIN: {\n    code: \"la\",\n    flag: \"name:la\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Luxembourgish language\n   */\n  LUXEMBOURGISH: {\n    code: \"lb\",\n    flag: \"name:lb\",\n    name: \"Luxembourgish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Lithuanian language\n   */\n  LITHUANIAN: {\n    code: \"lt\",\n    flag: \"name:lt\",\n    name: \"Lithuanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Latvian language\n   */\n  LATVIAN: {\n    code: \"lv\",\n    flag: \"name:lv\",\n    name: \"Latvian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Macedonian language\n   */\n  MACEDONIAN: {\n    code: \"mk\",\n    flag: \"name:mk\",\n    name: \"Macedonian\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Malayalm language\n   */\n  MALAYALAM: {\n    code: \"ml\",\n    flag: \"name:ml\",\n    name: \"Malayalam\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Maltese language\n   */\n  MALTESE: {\n    code: \"mt\",\n    flag: \"name:mt\",\n    name: \"Maltese\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Dutch language\n   */\n  DUTCH: {\n    code: \"nl\",\n    flag: \"name:nl\",\n    name: \"Dutch\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Norwegian language\n   */\n  NORWEGIAN: {\n    code: \"no\",\n    flag: \"name:no\",\n    name: \"Norwegian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Occitan language\n   */\n  OCCITAN: {\n    code: \"oc\",\n    flag: \"name:oc\",\n    name: \"Occitan\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Polish language\n   */\n  POLISH: {\n    code: \"pl\",\n    flag: \"name:pl\",\n    name: \"Polish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Persian language\n   */\n  PERSIAN: {\n    code: \"fa\",\n    flag: \"name:fa\",\n    name: \"Persian\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Punjabi language\n   */\n  PUNJABI: {\n    code: \"pa\",\n    flag: \"name:pa\",\n    name: \"Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Western Punjabi language\n   */\n  WESTERN_PUNJABI: {\n    code: \"pnb\",\n    flag: \"name:pnb\",\n    name: \"Western Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Portuguese language\n   */\n  PORTUGUESE: {\n    code: \"pt\",\n    flag: \"name:pt\",\n    name: \"Portuguese\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Romansh language\n   */\n  ROMANSH: {\n    code: \"rm\",\n    flag: \"name:rm\",\n    name: \"Romansh\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Romanian language\n   */\n  ROMANIAN: {\n    code: \"ro\",\n    flag: \"name:ro\",\n    name: \"Romanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Russian language\n   */\n  RUSSIAN: {\n    code: \"ru\",\n    flag: \"name:ru\",\n    name: \"Russian\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Slovak language\n   */\n  SLOVAK: {\n    code: \"sk\",\n    flag: \"name:sk\",\n    name: \"Slovak\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Slovene language\n   */\n  SLOVENE: {\n    code: \"sl\",\n    flag: \"name:sl\",\n    name: \"Slovene\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Albanian language\n   */\n  ALBANIAN: {\n    code: \"sq\",\n    flag: \"name:sq\",\n    name: \"Albanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Serbian language (cyrillic script)\n   */\n  SERBIAN_CYRILLIC: {\n    code: \"sr\",\n    flag: \"name:sr\",\n    name: \"Serbian (Cyrillic script)\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Serbian language (latin script)\n   */\n  SERBIAN_LATIN: {\n    code: \"sr-Latn\",\n    flag: \"name:sr-Latn\",\n    name: \"Serbian (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Swedish language\n   */\n  SWEDISH: {\n    code: \"sv\",\n    flag: \"name:sv\",\n    name: \"Swedish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Tamil language\n   */\n  TAMIL: {\n    code: \"ta\",\n    flag: \"name:ta\",\n    name: \"Tamil\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Telugu language\n   */\n  TELUGU: {\n    code: \"te\",\n    flag: \"name:te\",\n    name: \"Telugu\",\n    latin: false,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Thai language\n   */\n  THAI: {\n    code: \"th\",\n    flag: \"name:th\",\n    name: \"Thai\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Turkish language\n   */\n  TURKISH: {\n    code: \"tr\",\n    flag: \"name:tr\",\n    name: \"Turkish\",\n    latin: true,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Ukrainian language\n   */\n  UKRAINIAN: {\n    code: \"uk\",\n    flag: \"name:uk\",\n    name: \"Ukrainian\",\n    latin: false,\n    isMode: false,\n    geocoding: true,\n  } as LanguageInfo,\n\n  /**\n   * Vietnamese language (latin script)\n   */\n  VIETNAMESE: {\n    code: \"vi\",\n    flag: \"name:vi\",\n    name: \"Vietnamese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false,\n  } as LanguageInfo,\n} as const;\n\n/**\n * Get language infos from a provided language key, the key being the no-whitespace capital name.\n * By default, the language dictionnary to look into is the one defined in this library, but another one could be provided\n * Returns `null` if not found.\n */\nexport function getLanguageInfoFromKey(\n  languageKey: string,\n  languageDictionnary: { [k: string]: LanguageInfo } = Language,\n): LanguageInfo | null {\n  if (languageKey in languageDictionnary) {\n    return languageKey[languageKey];\n  }\n  return null;\n}\n\n/**\n * Get the language info from a provided 2-character iso code.\n * By default, the language dictionnary to look into is the one defined in this library, but another one could be provided\n * Returns `null` if not found.\n */\nexport function getLanguageInfoFromCode(\n  languageCode: string,\n  languageDictionnary: { [k: string]: LanguageInfo } = Language,\n): LanguageInfo | null {\n  for (const lang of Object.values(languageDictionnary)) {\n    if (lang.code === languageCode) {\n      return lang;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the language info from a language flag (eg. `\"name:en\"`).\n * This is also handy to check is a given language flag is a supported language.\n * By default, the language dictionnary to look into is the one defined in this library, but another one could be provided\n * Returns `null` if not found.\n */\nexport function getLanguageInfoFromFlag(\n  languageFlag: string,\n  languageDictionnary: { [k: string]: LanguageInfo } = Language,\n): LanguageInfo | null {\n  for (const lang of Object.values(languageDictionnary)) {\n    if (lang.flag === languageFlag) {\n      return lang;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the default language of the device, as a LanguageInfo object.\n */\nexport function getAutoLanguage(): LanguageInfo {\n  if (typeof navigator === \"undefined\") {\n    const code = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n    const langInfo = getLanguageInfoFromCode(code);\n    return langInfo ?? Language.ENGLISH;\n  }\n\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0])),\n  )\n    .map((code) => getLanguageInfoFromCode(code))\n    .filter((li) => li);\n\n  return canditatelangs[0] ?? Language.ENGLISH;\n}\n\nexport function isLanguageInfo(obj: unknown): obj is LanguageInfo {\n  return (\n    obj !== null &&\n    typeof obj === \"object\" &&\n    \"code\" in obj &&\n    \"flag\" in obj &&\n    \"name\" in obj &&\n    \"latin\" in obj &&\n    \"isMode\" in obj &&\n    \"geocoding\" in obj &&\n    (typeof obj.code === \"string\" || obj.code === null) &&\n    typeof obj.flag === \"string\" &&\n    typeof obj.name === \"string\" &&\n    typeof obj.latin === \"boolean\" &&\n    typeof obj.isMode === \"boolean\" &&\n    typeof obj.geocoding === \"boolean\"\n  );\n}\n\n/**\n * By default, the language dictionnary to look into is the one defined in this library, but another one could be provided\n */\nexport function toLanguageInfo(\n  lang: LanguageInfo | string,\n  languageDictionnary: { [k: string]: LanguageInfo } = Language,\n): LanguageInfo | null {\n  // Could be directly an object of type LanguageInfo\n  if (isLanguageInfo(lang)) {\n    // Yet we want to make sure the provided languageInfo obj is not corrupted or incomplete,\n    // so we ask for the equivalent original:\n    return getLanguageInfoFromFlag(lang.flag, languageDictionnary); // possibly returns null, which is fine.\n  }\n\n  // If it's not even a string, then it does not represent a language\n  if (typeof lang !== \"string\") {\n    return null;\n  }\n\n  return (\n    getLanguageInfoFromKey(lang, languageDictionnary) ||\n    getLanguageInfoFromCode(lang, languageDictionnary) ||\n    getLanguageInfoFromFlag(lang, languageDictionnary) ||\n    null\n  );\n}\n\n/**\n * Tells if two languages are the same, even though possibly provided under different forms.\n * Note: this is not comparing object references, but values.\n */\nexport function areSameLanguages(\n  langA: string | LanguageInfo,\n  langB: string | LanguageInfo,\n  languageDictionnary: { [k: string]: LanguageInfo } = Language,\n): boolean {\n  const langAObj = toLanguageInfo(langA, languageDictionnary);\n  const langBObj = toLanguageInfo(langB, languageDictionnary);\n\n  return langAObj && langBObj && langAObj.flag === langBObj.flag;\n}\n","import { config } from \"./config\";\n\nexport async function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\n      \"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\",\n    );\n  }\n\n  //  Control if URL contains the api key\n  if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n    throw new Error(\n      \"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\",\n    );\n  }\n\n  return config.fetch(resource, options);\n}\n","/**\n * Some default settings for the SDK\n */\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\",\n};\n\nObject.freeze(defaults);\n\nexport { defaults };\n","/**\n * A ServiceError is an Error that includes the HTTP response details\n */\nexport class ServiceError extends Error {\n  constructor(\n    public res: Response,\n    customMessage = \"\",\n  ) {\n    super(\n      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`,\n    );\n  }\n}\n","import type { BBox, Feature, Geometry, Position } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\n\nimport {\n  type LanguageInfo,\n  getAutoLanguage,\n  getLanguageInfoFromCode,\n  isLanguageInfo,\n  Language,\n  getLanguageInfoFromFlag,\n} from \"../language\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\",\n};\n\nexport type LanguageGeocodingOptions = {\n  /**\n   * Prefer results in specific language. Its possible to specify multiple values.\n   */\n  language?: string | Array<string> | LanguageInfo | Array<LanguageInfo>;\n};\n\nexport type CommonForwardAndReverseGeocodingOptions =\n  LanguageGeocodingOptions & {\n    /**\n     * Custom MapTiler Cloud API key to use instead of the one in global `config`\n     */\n    apiKey?: string;\n\n    /**\n     * Maximum number of results to show. Must be between 1 and 10. Default is 5 for forward and 1 for reverse geocoding.\n     */\n    limit?: number;\n\n    /**\n     * Filter of feature types to return.\n     * If not specified, feature of all available types except `poi` are returned (`types = [\"poi\"]`, `excludeTypes = true`).\n     */\n    types?: (\n      | \"country\"\n      | \"region\"\n      | \"subregion\"\n      | \"county\"\n      | \"joint_municipality\"\n      | \"joint_submunicipality\"\n      | \"municipality\"\n      | \"municipal_district\"\n      | \"locality\"\n      | \"neighbourhood\"\n      | \"place\"\n      | \"postal_code\"\n      | \"address\"\n      | \"road\"\n      | \"poi\"\n    )[];\n\n    /**\n     * Set to `true` to use all available feature types except those mentioned in `types`. Default value is `false` if `types` is specified.\n     */\n    excludeTypes?: boolean;\n  };\n\nexport type GeocodingOptions = CommonForwardAndReverseGeocodingOptions & {\n  /**\n   * Only search for results in the specified area.\n   */\n  bbox?: BBox;\n\n  /**\n   * Prefer results close to a specific location.\n   */\n  proximity?: Position | \"ip\";\n\n  /**\n   * Limit search to specific country/countries specified as list of Alpha-2 ISO 3166-1 codes.\n   */\n  country?: string[];\n\n  /**\n   * Set to `false` to disable fuzzy (typo-tolerant) search. Default is `true`.\n   */\n  fuzzyMatch?: boolean;\n\n  /**\n   * Set to `true` to use autocomplete, `false` to disable it. Default is `true`.\n   */\n  autocomplete?: boolean;\n};\n\nexport type ReverseGeocodingOptions = CommonForwardAndReverseGeocodingOptions;\n\nexport type ByIdGeocodingOptions = LanguageGeocodingOptions & {\n  apiKey?: string;\n};\n\nexport type Coordinates = Position;\n\ntype FeatureProperties = {\n  /**\n   * External reference of the feature used for debugging purposes\n   */\n  ref: string;\n\n  /**\n   * ISO 3166-1 alpha-2 country code of the feature\n   */\n  country_code: string;\n\n  /**\n   * (experimental) Kind of the feature\n   */\n  kind?:\n    | \"road\"\n    | \"road_relation\"\n    | \"admin_area\"\n    | \"place\"\n    | \"street\"\n    | \"virtual_street\";\n\n  /**\n   * (experimental) Value of place=* tag from OpenStreetMap feature if kind=place\n   */\n  \"osm:place_type\"?: string;\n\n  /**\n   * (experimental) Feature tags from OpenStreetMap. Only available for `poi` type.\n   */\n  \"osm:tags\"?: Record<string, string>;\n\n  /**\n   * Array of POI categories. Only available for `poi` type.\n   */\n  categories?: string[];\n\n  /**\n   * Wikidata identifier.\n   */\n  wikidata?: string;\n};\n\ntype FeatureBase = {\n  /**\n   * Unique feature ID\n   */\n  id: string;\n\n  /**\n   * Localized feature name\n   */\n  text: string;\n\n  /**\n   * Query's primary ISO 639-1 language code\n   */\n  language?: string;\n\n  /**\n   * A string analogous to the `text` field that matches the query in the requested language.\n   * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n   */\n  [text: `text_${string}`]: string;\n\n  /**\n   * A ISO 639-1 query's fallback language code.\n   * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n   */\n  [language: `language_${string}`]: string;\n};\n\nexport type FeatureHierarchy = FeatureProperties & FeatureBase;\n\nexport type GeocodingFeature = Feature<Geometry, FeatureProperties> &\n  FeatureBase & {\n    /**\n     * Bounding box of the original feature as [w, s, e, n] array\n     */\n    bbox: BBox;\n\n    /**\n     * A [lon, lat] array of the original feature centeroid\n     */\n    center: Coordinates;\n\n    /**\n     * Formatted (including the hierarchy) and localized feature full name\n     */\n    place_name: string;\n\n    /**\n     * A string analogous to the `place_name` field that matches the query in the requested language.\n     * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n     */\n    [key: `place_name_${string}`]: string;\n\n    /**\n     * An array of feature types describing the feature.\n     * Currently each feature has only single type but this may change in the future.\n     */\n    place_type: string[];\n\n    /**\n     * Localized type of the place name, matches `place_type` property\n     */\n    place_type_name: string[];\n\n    /**\n     * Feature hierarchy\n     */\n    context?: Array<FeatureHierarchy>;\n\n    /**\n     * Address number, if applicable\n     */\n    address?: string;\n\n    /**\n     * Indicates how well the returned feature matches the user's query on a scale from 0 to 1.\n     * 0 means the result does not match the query text at all, while 1 means the result fully matches the query text.\n     * You can use the relevance property to remove results that don't fully match the query.\n     */\n    relevance: number;\n\n    /**\n     * A string analogous to the `text` field that more closely matches the query than results in the specified language.\n     * For example, querying _Praha, Czechia_ with language set to English (`en`) might return a feature with the `text` _Prague_ and the `matching_text` _Praha_.\n     */\n    matching_text?: string;\n\n    /**\n     * A string analogous to the `place_name` field that more closely matches the query than results in the specified language.\n     * For example, querying _Praha, Czechia_ with language set to English (`en`) might return a feature with the `place_name` _Prague, Czechia_ and a `matching_place_name` of _Praha, Czechia_.\n     */\n    matching_place_name?: string;\n  };\n\nexport type GeocodingSearchResult = {\n  type: \"FeatureCollection\";\n\n  /**\n   * Array of features found\n   */\n  features: Array<GeocodingFeature>;\n\n  /**\n   * Tokenized search query\n   */\n  query: Array<string>;\n\n  /**\n   * Attribution of the result\n   */\n  attribution: string;\n};\n\nfunction addLanguageGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: LanguageGeocodingOptions,\n) {\n  const { language } = options;\n\n  if (language === undefined) {\n    return;\n  }\n\n  // Making it an array of language codes\n  const languageCodes = (Array.isArray(language) ? language : [language])\n    .map((elem) => toValidGeocodingLanguageCode(elem))\n    .filter((elem) => elem); // removing the nulls\n\n  const languages = Array.from(new Set(languageCodes)).join(\",\");\n\n  searchParams.set(\"language\", languages);\n}\n\nfunction toValidGeocodingLanguageCode(\n  lang: string | LanguageInfo,\n): string | null {\n  let langInfo: LanguageInfo | null = null;\n\n  if (lang === Language.AUTO.flag) {\n    // equal to the string \"auto\"\n    langInfo = getAutoLanguage();\n  } else if (typeof lang === \"string\") {\n    langInfo = getLanguageInfoFromCode(lang);\n  } else if (isLanguageInfo(lang)) {\n    langInfo =\n      lang.flag === Language.AUTO.flag\n        ? getAutoLanguage()\n        : getLanguageInfoFromFlag(lang.flag);\n  }\n\n  if (!langInfo) return null;\n  if (langInfo.geocoding) return langInfo.code;\n  return null;\n}\n\nfunction addCommonForwardAndReverseGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: CommonForwardAndReverseGeocodingOptions,\n) {\n  const { apiKey, limit, types, excludeTypes } = options;\n\n  searchParams.set(\"key\", apiKey ?? config.apiKey);\n\n  if (limit !== undefined) {\n    searchParams.set(\"limit\", String(limit));\n  }\n\n  if (types !== undefined) {\n    searchParams.set(\"types\", types.join(\",\"));\n  }\n\n  if (excludeTypes !== undefined) {\n    searchParams.set(\"excludeTypes\", String(excludeTypes));\n  }\n\n  addLanguageGeocodingOptions(searchParams, options);\n}\n\nfunction addForwardGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: GeocodingOptions,\n) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n\n  const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;\n\n  if (bbox !== undefined) {\n    searchParams.set(\"bbox\", bbox.join(\",\"));\n  }\n\n  if (proximity !== undefined) {\n    searchParams.set(\n      \"proximity\",\n      proximity === \"ip\" ? proximity : proximity.join(\",\"),\n    );\n  }\n\n  if (country !== undefined) {\n    searchParams.set(\"country\", country.join(\",\"));\n  }\n\n  if (fuzzyMatch !== undefined) {\n    searchParams.set(\"fuzzyMatch\", fuzzyMatch ? \"true\" : \"false\");\n  }\n\n  if (autocomplete !== undefined) {\n    searchParams.set(\"autocomplete\", autocomplete ? \"true\" : \"false\");\n  }\n}\n\n/**\n * Performs a forward geocoding query to MapTiler API.\n * Providing a human readable place name (of a city, country, street, etc.), the function returns\n * a list of candidate locations including longitude and latitude.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-name-forward\n * @param query\n * @param options\n * @returns\n */\nasync function forward(\n  query: string,\n  options: GeocodingOptions = {},\n): Promise<GeocodingSearchResult> {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `geocoding/${encodeURIComponent(query)}.json`,\n    defaults.maptilerApiURL,\n  );\n\n  const { searchParams } = endpoint;\n\n  addForwardGeocodingOptions(searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a reverse geocoding query to MapTiler API.\n * Providing a longitude and latitude, this function returns a set of human readable information about this place (country, city, street, etc.)\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-coordinates-reverse\n * @param position\n * @param options\n * @returns\n */\nasync function reverse(\n  position: Position,\n  options: ReverseGeocodingOptions = {},\n): Promise<GeocodingSearchResult> {\n  if (!Array.isArray(position) || position.length < 2) {\n    throw new Error(\"The position must be an array of form [lng, lat].\");\n  }\n\n  const endpoint = new URL(\n    `geocoding/${position[0]},${position[1]}.json`,\n    defaults.maptilerApiURL,\n  );\n\n  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a geocoding query to MapTiler API to obtain fature by its ID.\n * Providing a feature ID, this function returns a feature which includes its full geometry.\n * Note that the feature ID is not stable and it changes when the database is re-indexed.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-feature-id\n * @param id\n * @param options\n * @returns\n */\nasync function byId(\n  id: string,\n  options: ByIdGeocodingOptions = {},\n): Promise<GeocodingSearchResult> {\n  const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  addLanguageGeocodingOptions(endpoint.searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a batch geocoding query to MapTiler API.\n * Provide multiple queries in the array. Each query can be forward, reverse or by feature ID.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#batch-geocoding\n * @param queries\n * @param options\n * @returns\n */\nasync function batch(\n  queries: string[],\n  options: GeocodingOptions = {},\n): Promise<GeocodingSearchResult[]> {\n  if (!queries.length) {\n    return [];\n  }\n\n  const joinedQuery = queries\n    .map((query) => encodeURIComponent(query))\n    .join(\";\");\n\n  const endpoint = new URL(\n    `geocoding/${joinedQuery}.json`,\n    defaults.maptilerApiURL,\n  );\n\n  const { searchParams } = endpoint;\n\n  addForwardGeocodingOptions(searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj = await res.json();\n\n  return queries.length === 1 ? [obj] : obj;\n}\n\n/**\n * The **geocoding** namespace contains asynchronous functions to call the [MapTiler Geocoding API](https://docs.maptiler.com/cloud/api/geocoding/).\n * The **Geocoding API** provides ways to get geographic coordinates from a human-readable search query of a place (forward geocoding)\n * and to get the location details (country, city, street, etc.) from a geographic coordinate (reverse geocoding);\n */\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch,\n};\n\nexport { geocoding };\n","import { BBox } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Options that can be provided to get user data.\n */\nexport type GeolocationInfoOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n};\n\nexport type GeolocationResult = {\n  /**\n   * Name of the country\n   * Example: Switzerland\n   */\n  country?: string;\n\n  /**\n   * Two-letter code of the country ISO 3166-1 alpha-2 codes\n   * Example: CH\n   */\n  country_code?: string;\n\n  /**\n   * Bounds of the country in WGS84 degrees [west, south, east, north].\n   * Example: [5.95538,45.818852,10.490936,47.809357]\n   */\n  country_bounds?: BBox;\n\n  /**\n   * Official country languages in ISO 639-1 format. ISO 639-1 codes\n   * Example: [\"de\",\"fr\",\"it\"]\n   */\n  country_languages?: Array<string>;\n\n  /**\n   * Name of the continent\n   * Example: Europe\n   */\n  continent?: string;\n\n  /**\n   * Two-letter code of the continent\n   * Example: EU\n   */\n  continent_code?: string;\n\n  /**\n   * Indicated whether the country is part of the European Union.\n   */\n  eu?: boolean;\n\n  /**\n   * Name of the city\n   * Example: Zurich\n   */\n  city?: string;\n\n  /**\n   * Latitude of the location\n   * Example: 47.36667\n   */\n  latitude?: number;\n\n  /**\n   * Longitude of the location\n   * Example: 8.55\n   */\n  longitude?: number;\n\n  /**\n   * Postal code\n   * Example: 8000\n   */\n  postal?: string;\n\n  /**\n   * If known, the ISO 3166-2 name for the first level region. ISO 3166-2 codes\n   * Example: Zurich\n   */\n  region?: string;\n\n  /**\n   * If known, the ISO 3166-2 code for the first level region. ISO 3166-2 codes\n   * Example: ZH\n   */\n  region_code?: string;\n\n  /**\n   * Name of the timezone\n   * Example: Europe/Zurich\n   */\n  timezone?: string;\n};\n\n/**\n * Looks up geolocation details from IP address using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geolocation/#ip-geolocation\n * @returns\n */\nasync function info(\n  options: GeolocationInfoOptions = {},\n): Promise<GeolocationResult> {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\",\n    );\n  }\n\n  const obj = await res.json();\n  return obj as GeolocationResult;\n}\n\n/**\n * The **geolocation** namespace contains an asynchronous function to call the [MapTiler Geolocation API](https://docs.maptiler.com/cloud/api/geolocation/).\n * The **Geolocation API** provides a way to retrieve the IP address as well as geographic informations of a machine performing the query (most likely: a user)\n */\nconst geolocation = {\n  info,\n};\n\nexport { geolocation };\n","import { BBox, Position } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\nexport type CoordinatesSearchOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Maximum number of results returned (default: 10)\n   */\n  limit?: number;\n\n  /**\n   *  Show detailed transformations for each CRS (default: false)\n   */\n  transformations?: boolean;\n\n  /**\n   * Show exports in WKT and Proj4 notations (default: false)\n   */\n  exports?: boolean;\n};\n\nexport type CoordinateId = {\n  authority: string;\n  code: BigInteger;\n};\n\nexport type CoordinateExport = {\n  proj4: string;\n  wkt: string;\n};\n\nexport type CoordinateGrid = {\n  path: string;\n};\n\nexport type CoordinateTransformation = {\n  id: CoordinateId;\n  name: string;\n  reversible: boolean;\n  usable: boolean;\n  deprecated: boolean;\n  grids: Array<CoordinateGrid>;\n  accuracy?: number;\n  area?: string;\n  bbox?: BBox;\n  target_crs?: CoordinateId;\n  unit?: string;\n};\n\nexport type CoordinateSearch = {\n  id: CoordinateId;\n\n  name: string;\n\n  kind: string;\n\n  deprecated: boolean;\n\n  transformations?: Array<CoordinateTransformation | number>;\n\n  accuracy?: number;\n\n  unit?: string;\n\n  area?: string;\n\n  /**\n   * Bounding box of the resource in [min_lon, min_lat, max_lon, max_lat] order.\n   */\n  bbox?: BBox;\n\n  /**\n   * Most suitable transformation for this CRS.\n   */\n  default_transformation?: DefaultTransformation;\n\n  exports: CoordinateExport;\n};\n\nexport type DefaultTransformation = {\n  authority: string;\n  code: number;\n};\n\nexport type CoordinateSearchResult = {\n  /**\n   * The coordinate search results\n   */\n  results: Array<CoordinateSearch>;\n\n  /**\n   * The number of results\n   */\n  total: number;\n};\n\n/**\n * Search information about coordinate systems using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#search-coordinate-systems\n * @param query Can be any kind of CRS by name or code\n * @param options\n * @returns\n */\nasync function search(\n  query: string,\n  options: CoordinatesSearchOptions = {},\n): Promise<CoordinateSearchResult> {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `coordinates/search/${query}.json`,\n    defaults.maptilerApiURL,\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\n      \"transformations\",\n      options.transformations.toString(),\n    );\n  }\n\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\",\n    );\n  }\n\n  const obj = await res.json();\n  return obj as CoordinateSearchResult;\n}\n\nexport type XYZ = {\n  x?: number;\n  y?: number;\n  z?: number;\n};\n\nexport type CoordinateTransformResult = {\n  results: Array<XYZ>;\n\n  /**\n   * Transformations are selected using given ops parameter.\n   * If no parameter is given, auto strategy is used.\n   * If given, it may try to use a listed transformation,\n   * then fallback to towgs84 patching, and finally boundcrs.\n   */\n  transformer_selection_strategy: string;\n};\n\n/**\n * Options that can be provided when transforming a coordinate from one CRS to another.\n */\nexport type CoordinatesTransformOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Source coordinate reference system (default: 4326)\n   */\n  sourceCrs?: number;\n\n  /**\n   * Target coordinate reference system (default: 4326)\n   */\n  targetCrs?: number;\n\n  /**\n   * List of codes of operations\n   */\n  operations?: number | Array<number>;\n};\n\n/**\n * Transforms coordinates from a source reference system to a target reference system using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#transform-coordinates\n * @param positions\n * @param options\n * @returns\n */\nasync function transform(\n  positions: Position | Array<Position>,\n  options: CoordinatesTransformOptions = {},\n): Promise<CoordinateTransformResult> {\n  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions])\n    .map((coord) => `${coord[0]},${coord[1]}`)\n    .join(\";\");\n\n  const endpoint = new URL(\n    `coordinates/transform/${coordinatesStr}.json`,\n    defaults.maptilerApiURL,\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\n      \"ops\",\n      (Array.isArray(options.operations)\n        ? options.operations\n        : [options.operations]\n      ).join(\"|\"),\n    );\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\",\n    );\n  }\n\n  const obj = await res.json();\n  return obj as CoordinateTransformResult;\n}\n\n/**\n * The **coordinate** namespace contains asynchronous functions to call the [MapTiler Coordinate API](https://docs.maptiler.com/cloud/api/coordinates/).\n * The goal of the **Coordinate API* is query information about spatial coordinate reference system (CRS) as well as to transform coordinates from one CRS to another.\n */\nconst coordinates = {\n  search,\n  transform,\n};\n\nexport { coordinates };\n","import { FeatureCollection } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Options that can be provided to get user data.\n */\nexport type GetDataOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n};\n\n/**\n * Get user data and returns it as GeoJSON using the MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/data/#geojson\n * @param dataId\n * @returns\n */\nasync function get(\n  dataId: string,\n  options: GetDataOptions = {},\n): Promise<FeatureCollection> {\n  if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n    throw new Error(\"The data ID must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `data/${encodeURIComponent(dataId)}/features.json`,\n    defaults.maptilerApiURL,\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\",\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * The **data** namespace contains an asynchronous function to call the [MapTiler Data API](https://docs.maptiler.com/cloud/api/data/).\n * The **Data API** provides a way to retrieve user data in GeoJSON format.\n */\nconst data = {\n  get,\n};\n\nexport { data };\n","/**\n * Expand the map style provided as argument of the Map constructor\n * @param style\n * @returns\n */\nexport function expandMapStyle(style): string {\n  // testing if the style provided is of form \"maptiler://some-style\"\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n\n  // The style was possibly already given as expanded URL\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    // The style could also possibly just be the name of the style without any URI style\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n\n  return expandedStyle;\n}\n\n/**\n * Type for object containing style details\n */\nexport type MapStylePreset = {\n  referenceStyleID: string;\n  name: string;\n  description: string;\n  variants: Array<{\n    id: string;\n    name: string;\n    variantType: string;\n    description: string;\n    imageURL: string;\n  }>;\n};\n\n/**\n * An instance of MapStyleVariant contains information about a style to use that belong to a reference style\n */\nexport class MapStyleVariant {\n  constructor(\n    /**\n     * Human-friendly name\n     */\n    private name: string,\n\n    /**\n     * Variant name the variant is addressed to from its reference style: `MapStyle.REFERNCE_STYLE_NAME.VARIANT_TYPE`\n     */\n    private variantType: string,\n\n    /**\n     * MapTiler Cloud id\n     */\n    private id: string,\n\n    /**\n     * Reference map style, used to retrieve sibling variants\n     */\n    private referenceStyle: ReferenceMapStyle,\n\n    /**\n     * Human-friendly description\n     */\n    private description: string,\n\n    /**\n     * URL to an image describing the style variant\n     */\n    private imageURL: string,\n  ) {}\n\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  getFullName(): string {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType(): string {\n    return this.variantType;\n  }\n\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Get the human-friendly description\n   */\n  getDescription(): string {\n    return this.description;\n  }\n\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle(): ReferenceMapStyle {\n    return this.referenceStyle;\n  }\n\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType: string): boolean {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType: string): MapStyleVariant {\n    return this.referenceStyle.getVariant(variantType);\n  }\n\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants(): Array<MapStyleVariant> {\n    return this.referenceStyle.getVariants().filter((v) => v !== this);\n  }\n\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL(): string {\n    return this.imageURL;\n  }\n\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL(): string {\n    return expandMapStyle(this.getId());\n  }\n}\n\n/**\n * An instance of reference style contains a list of StyleVariants ordered by relevance\n */\nexport class ReferenceMapStyle {\n  /**\n   * Variants that belong to this reference style, key being the reference type\n   */\n  private variants: { [key: string]: MapStyleVariant } = {};\n\n  /**\n   * Variants that belong to this reference style, ordered by relevance\n   */\n  private orderedVariants: Array<MapStyleVariant> = [];\n\n  constructor(\n    /**\n     * Human-friendly name of this reference style\n     */\n    private name: string,\n\n    /**\n     * ID of this reference style\n     */\n    private id: string,\n  ) {}\n\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v: MapStyleVariant) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType: string): boolean {\n    return variantType in this.variants;\n  }\n\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType: string): MapStyleVariant {\n    return variantType in this.variants\n      ? this.variants[variantType]\n      : this.orderedVariants[0];\n  }\n\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants(): Array<MapStyleVariant> {\n    return Object.values(this.variants);\n  }\n\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant(): MapStyleVariant {\n    return this.orderedVariants[0];\n  }\n}\n\n/**\n * All the styles and variants maintained by MapTiler.\n */\nexport type MapStyleType = {\n  /**\n   * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings\n   */\n  STREETS: ReferenceMapStyle & {\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings.\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in dark mode.\n     */\n    DARK: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in light mode.\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in blue night mode.\n     */\n    NIGHT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, with a pastel color palette.\n     */\n    PASTEL: MapStyleVariant;\n  };\n\n  /**\n   * Suitable for outdoor activities. With elevation isolines and hillshading.\n   */\n  OUTDOOR: ReferenceMapStyle & {\n    /**\n     * Suitable for outdoor activities. With elevation isolines and hillshading.\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     * Suitable for outdoor activities. With elevation isolines and hillshading, in dark mode.\n     */\n    DARK: MapStyleVariant;\n  };\n\n  /**\n   * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading.\n   */\n  WINTER: ReferenceMapStyle & {\n    /**\n     * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading.\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading, in dark mode.\n     */\n    DARK: MapStyleVariant;\n  };\n\n  /**\n   * High resolution imagery only, without any label.\n   */\n  SATELLITE: ReferenceMapStyle & {\n    /**\n     * High resolution imagery only, without any label.\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * High resolution imagery with labels, political borders and roads.\n   */\n  HYBRID: ReferenceMapStyle & {\n    /**\n     * High resolution imagery with labels, political borders and roads.\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * A minimalist street-oriented style without POI\n   */\n  BASIC: ReferenceMapStyle & {\n    /**\n     * A minimalist street-oriented style without POI\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A minimalist street-oriented style without POI, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A minimalist street-oriented style without POI, in light mode\n     */\n    LIGHT: MapStyleVariant;\n  };\n\n  /**\n   * A bright street-oriented style, a nice alternative to `streets`\n   */\n  BRIGHT: ReferenceMapStyle & {\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, in light mode\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, with a soft pastel color palette\n     */\n    PASTEL: MapStyleVariant;\n  };\n\n  /**\n   * Classic OpenStreetMap style\n   */\n  OPENSTREETMAP: ReferenceMapStyle & {\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n   */\n  TOPO: ReferenceMapStyle & {\n    /**\n     * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A nice high-contrast, and high saturation alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    SHINY: MapStyleVariant;\n    /**\n     * A nice low-contrast, alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details, using a soft pastel color palette\n     */\n    PASTEL: MapStyleVariant;\n\n    /**\n     * A nice very high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    TOPOGRAPHIQUE: MapStyleVariant;\n  };\n\n  /**\n   * A nice alternative to `streets` with a soft color palette\n   */\n  VOYAGER: ReferenceMapStyle & {\n    /**\n     * A nice alternative to `streets` with a soft color palette\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A nice alternative to `streets`, in very dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A nice alternative to `streets`, in light mode\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * A nice alternative to `streets` with a soft sepia color palette and vintage look\n     */\n    VINTAGE: MapStyleVariant;\n  };\n\n  /**\n   * A bold very high contrast black and white (no gray!) style for the city\n   */\n  TONER: ReferenceMapStyle & {\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city, without any label\n     */\n    BACKGROUND: MapStyleVariant;\n    /**\n     * A bold very high contrast, yet faded, style for the city\n     */\n    LITE: MapStyleVariant;\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city, with no building, only roads!\n     */\n    LINES: MapStyleVariant;\n  };\n\n  /**\n   * Minimalist style, perfect for data visualization\n   */\n  DATAVIZ: ReferenceMapStyle & {\n    /**\n     *  Minimalist style, perfect for data visualization\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     *  Minimalist style, perfect for data visualization in dark mode\n     */\n    DARK: MapStyleVariant;\n\n    /**\n     *  Minimalist style, perfect for data visualization in light mode\n     */\n    LIGHT: MapStyleVariant;\n  };\n\n  /**\n   * Explore deep see trenches and mountains, with isolines and depth labels\n   */\n  OCEAN: ReferenceMapStyle & {\n    /**\n     * Explore deep see trenches and mountains, with isolines and depth labels\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * Neutral greyscale style with hillshading suitable for colorful terrain-aware visualization\n   */\n  BACKDROP: ReferenceMapStyle & {\n    /**\n     *  Neutral greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     *  Dark greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    DARK: MapStyleVariant;\n\n    /**\n     *  Light greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    LIGHT: MapStyleVariant;\n  };\n};\n\nexport const mapStylePresetList: Array<MapStylePreset> = [\n  {\n    referenceStyleID: \"STREETS\",\n    name: \"Streets\",\n    description: \"\",\n    variants: [\n      {\n        id: \"streets-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-night\",\n        name: \"Night\",\n        variantType: \"NIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OUTDOOR\",\n    name: \"Outdoor\",\n    description: \"\",\n    variants: [\n      {\n        id: \"outdoor-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"outdoor-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"WINTER\",\n    name: \"Winter\",\n    description: \"\",\n    variants: [\n      {\n        id: \"winter-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"winter-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"SATELLITE\",\n    name: \"Satellite\",\n    description: \"\",\n    variants: [\n      {\n        id: \"satellite\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"HYBRID\",\n    name: \"Hybrid\",\n    description: \"\",\n    variants: [\n      {\n        id: \"hybrid\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BASIC\",\n    name: \"Basic\",\n    description: \"\",\n    variants: [\n      {\n        id: \"basic-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"basic-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"basic-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BRIGHT\",\n    name: \"Bright\",\n    description: \"\",\n    variants: [\n      {\n        id: \"bright-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OPENSTREETMAP\",\n    name: \"OpenStreetMap\",\n    description: \"\",\n    variants: [\n      {\n        id: \"openstreetmap\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"TOPO\",\n    name: \"Topo\",\n    description: \"\",\n    variants: [\n      {\n        id: \"topo-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-shiny\",\n        name: \"Shiny\",\n        variantType: \"SHINY\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-topographique\",\n        name: \"Topographique\",\n        variantType: \"TOPOGRAPHIQUE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"VOYAGER\",\n    name: \"Voyager\",\n    description: \"\",\n    variants: [\n      {\n        id: \"voyager-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-darkmatter\",\n        name: \"Darkmatter\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-positron\",\n        name: \"Positron\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-vintage\",\n        name: \"Vintage\",\n        variantType: \"VINTAGE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"TONER\",\n    name: \"Toner\",\n    description: \"\",\n    variants: [\n      {\n        id: \"toner-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-background\",\n        name: \"Background\",\n        variantType: \"BACKGROUND\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-lite\",\n        name: \"Lite\",\n        variantType: \"LITE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-lines\",\n        name: \"Lines\",\n        variantType: \"LINES\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"DATAVIZ\",\n    name: \"Dataviz\",\n    description: \"\",\n    variants: [\n      {\n        id: \"dataviz\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"dataviz-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"dataviz-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BACKDROP\",\n    name: \"Backdrop\",\n    description: \"\",\n    variants: [\n      {\n        id: \"backdrop\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"backdrop-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"backdrop-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OCEAN\",\n    name: \"Ocean\",\n    description: \"\",\n    variants: [\n      {\n        id: \"ocean\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n];\n\nfunction makeReferenceStyleProxy(referenceStyle: ReferenceMapStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop as string)) {\n        return target.getVariant(prop as string);\n      }\n\n      // This variant does not exist for this style, but since it's full uppercase\n      // we guess that the dev tries to access a style variant. So instead of\n      // returning the default (STREETS.DEFAULT), we return the non-variant of the current style\n      if (prop.toString().toUpperCase() === (prop as string)) {\n        return referenceStyle.getDefaultVariant();\n      }\n\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\nfunction buildMapStyles(): MapStyleType {\n  const mapStyle = {};\n\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n\n    const refStyle = makeReferenceStyleProxy(\n      new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID),\n    );\n\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(\n        variantInfo.name, // name\n        variantInfo.variantType, // variantType\n        variantInfo.id, // id\n        refStyle, // referenceStyle\n        variantInfo.description,\n        variantInfo.imageURL, // imageURL\n      );\n\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle as MapStyleType;\n}\n\nexport function styleToStyle(\n  style: string | ReferenceMapStyle | MapStyleVariant | null | undefined,\n): string {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID]\n      .getDefaultVariant()\n      .getId();\n  }\n\n  // If the provided style is a shorthand (eg. \"streets-v2\") then we make sure it's trimmed and lowercase\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\n\n/**\n * Contains all the reference map style created by MapTiler team as well as all the variants.\n * For example, `MapStyle.STREETS` and the variants:\n * - `MapStyle.STREETS.DARK`\n * - `MapStyle.STREETS.LIGHT`\n * - `MapStyle.STREETS.PASTEL`\n *\n */\nexport const MapStyle: MapStyleType = buildMapStyles();\n","import {\n  GeoJsonObject,\n  GeometryObject,\n  LineString,\n  MultiLineString,\n  Feature,\n  FeatureCollection,\n  Position,\n} from \"geojson\";\n\n/**\n * From a generic GeoJSON object extract thepossibly nested LineString and MultiLineString features\n * it contains. The result is a flat array made of LineString and MultiLineString.\n */\nfunction extractLineStrings(\n  geoJson: GeoJsonObject,\n): Array<LineString | MultiLineString> {\n  const lineStrings: Array<LineString | MultiLineString> = [];\n\n  function extractFromGeometry(geometry: GeometryObject) {\n    if (geometry.type === \"LineString\" || geometry.type === \"MultiLineString\") {\n      lineStrings.push(geometry as LineString | MultiLineString);\n    }\n  }\n\n  function extractFromFeature(feature: Feature) {\n    if (feature.geometry) {\n      extractFromGeometry(feature.geometry);\n    }\n  }\n\n  function extractFromFeatureCollection(collection: FeatureCollection) {\n    for (const feature of collection.features) {\n      if (feature.type === \"Feature\") {\n        extractFromFeature(feature);\n      } else if (feature.type === \"FeatureCollection\") {\n        extractFromFeatureCollection(feature as unknown as FeatureCollection); // had to add unknown\n      }\n    }\n  }\n\n  if (geoJson.type === \"Feature\") {\n    extractFromFeature(geoJson as Feature);\n  } else if (geoJson.type === \"FeatureCollection\") {\n    extractFromFeatureCollection(geoJson as FeatureCollection);\n  } else {\n    // It's a single geometry\n    extractFromGeometry(geoJson as GeometryObject);\n  }\n\n  return lineStrings;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p: Position, p1: Position, p2: Position): number {\n  let x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n}\n\nfunction simplifyDPStep(\n  points: Array<Position>,\n  first: number,\n  last: number,\n  sqTolerance: number,\n  simplified: Array<Position>,\n) {\n  let maxSqDist = sqTolerance,\n    index;\n\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(\n  points: Array<Position>,\n  sqTolerance: number,\n): Array<Position> {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\n\n/**\n * Simplify a path made of a list of GeoJSON Positions, with a tolerance.\n */\nfunction simplify(points: Array<Position>, tolerance: number): Array<Position> {\n  if (points.length <= 2) {\n    return points;\n  }\n\n  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\n\nexport const misc = {\n  extractLineStrings,\n  simplify,\n};\n","import { BBox, Position } from \"geojson\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { MapStyleVariant, ReferenceMapStyle, styleToStyle } from \"../mapstyle\";\nimport { misc } from \"../misc\";\n\n/**\n * Base set of options that can be provided to all the types of static maps\n */\nexport type StaticMapBaseOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Style of the map (not full style URL). Example: \"winter\", \"streets-v2\".\n   * Default: `\"streets-v2\"`\n   */\n  style?: string | ReferenceMapStyle | MapStyleVariant;\n\n  /**\n   * Double the size of the static map image to support hiDPI/Retina monitors.\n   * Default: `false`\n   */\n  hiDPI?: boolean;\n\n  /**\n   * Image format.\n   * Default: `\"png\"`\n   */\n  format?: \"png\" | \"jpg\" | \"webp\";\n\n  /**\n   * Width of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  width?: number;\n\n  /**\n   * Height of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  height?: number;\n\n  /**\n   * Placement of the attribution. Can also be set to `false` to not show attribution.\n   * Default: `\"bottomright\"`\n   */\n  attribution?: \"bottomright\" | \"bottomleft\" | \"topleft\" | \"topright\" | false;\n\n  /**\n   * A marker or list of markers to show on the map\n   * Default: none provided\n   */\n  markers?: StaticMapMarker | Array<StaticMapMarker>;\n\n  /**\n   * URL of the marker image. Applies only if one or multiple markers positions are provided.\n   * Default: none provided\n   */\n  markerIcon?: string;\n\n  /**\n   * Position of the marker regarding its coordinates. Applies only:\n   * - with a custom icon provided with `markerIcon`\n   * - if one or multiple markers positions are provided.\n   * Default: `\"bottom\"`\n   */\n  markerAnchor?:\n    | \"top\"\n    | \"left\"\n    | \"bottom\"\n    | \"right\"\n    | \"center\"\n    | \"topleft\"\n    | \"bottomleft\"\n    | \"topright\"\n    | \"bottomright\";\n\n  /**\n   * Draw a path or polygon on top of the map. If the path is too long it will be simplified, yet remaining accurate.\n   * Default: none provided\n   */\n  path?: Array<Position>;\n\n  /**\n   * Color of the path line. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: `\"blue\"`\n   */\n  pathStrokeColor?: string;\n\n  /**\n   * Color of the filling, also works if the polygon is not closed. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: none (transparent filling)\n   */\n  pathFillColor?: string;\n\n  /**\n   * Width of the path line in pixel. It can be floating point precision (ex: `0.5`)\n   * Default: `1` if `hiDPI` is `false` and `2` if `hiDPI` is `true`.\n   */\n  pathWidth?: number;\n};\n\n/**\n * Options that can be provided to centered static maps\n */\nexport type CenteredStaticMapOptions = StaticMapBaseOptions;\n\n/**\n * Options that can be provided to bounded static maps\n */\nexport type BoundedStaticMapOptions = StaticMapBaseOptions & {\n  /**\n   * Extra space added around the regio of interest, in percentage.\n   * Default: `0.1` (for 10%)\n   */\n  padding?: number;\n};\n\n/**\n * Options that can be provided to automatic static maps\n */\nexport type AutomaticStaticMapOptions = BoundedStaticMapOptions;\n\n/**\n * Definition of a maker to show on a static map\n */\nexport type StaticMapMarker = [\n  /**\n   * Longitude of the marker\n   */\n  number,\n  /**\n   * latitude of the marker\n   */\n  number,\n  /**\n   * Color of the marker with CSS syntax. Applies only if a custom `markerIcon` is not provided.\n   */\n  string,\n];\n\nfunction staticMapMarkerToString(\n  marker: StaticMapMarker,\n  includeColor = true,\n): string {\n  let str = `${marker[0]},${marker[1]}`;\n\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n\n  return str;\n}\n\nfunction simplifyAndStringify(path: Array<Position>, maxNbChar = 3000): string {\n  let str = path.map((point) => point.join(\",\")).join(\"|\");\n  let tolerance = 0.000005;\n  const toleranceStep = 0.00001;\n\n  while (str.length > maxNbChar) {\n    const simplerPath = misc.simplify(path, tolerance);\n    // str = simplerPath.map(point => point.join(',')).join('|');\n    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n\n  return str;\n}\n\n/**\n * Construct the URL for a static map centered on one point.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param center\n * @param zoom\n * @param options\n * @returns\n */\nfunction centered(\n  center: Position,\n  zoom: number,\n  options: CenteredStaticMapOptions = {},\n): string {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${center[0]},${\n      center[1]\n    },${zoom}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL,\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map using a bounding box\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param boundingBox\n * @param options\n * @returns\n */\nfunction bounded(\n  boundingBox: BBox,\n  options: BoundedStaticMapOptions = {},\n): string {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${\n      boundingBox[1]\n    },${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL,\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map automatically fitted around the provided path or markers.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param options\n * @returns\n */\nfunction automatic(options: AutomaticStaticMapOptions = {}): string {\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\n      \"Automatic static maps require markers and/or path to be created.\",\n    );\n  }\n\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(\n      style,\n    )}/static/auto/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL,\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * The **staticMaps** namespace contains an synchronous function build image URL of static map, as specified by the [MapTiler Static Map API](https://docs.maptiler.com/cloud/api/static-maps/).\n * The URL of static maps can then be used within a `<img />` markup element, as the `src` property value.\n */\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic,\n};\n\nexport { staticMaps };\n","import { Position } from \"geojson\";\n\n/**\n * Average radius of Earth in meters\n */\nconst EARTH_RADIUS = 6371008.8;\n\n/**\n * Average circumfrence of Earth in meters\n */\nconst EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;\n\n/**\n * Convert a wgs84 longitude to web Mercator X (west-east axis), where westmost X is 0 and eastmost X is 1.\n */\nfunction longitudeToMercatorX(lng: number): number {\n  return (180 + lng) / 360;\n}\n\n/**\n * Convert a wgs84 latitude to web Mercator Y (north-south axis), where northmost Y is 0 and southmost Y is 1.\n */\nfunction latitudeToMercatorY(lat: number): number {\n  return (\n    (180 -\n      (180 / Math.PI) *\n        Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI) / 360))) /\n    360\n  );\n}\n\n/**\n * Convert a wgs84 position into a web Mercator position where north-west is [0, 0] and south-east is [1, 1]\n */\nfunction wgs84ToMercator(position: Position): Position {\n  const wrappedPos = wrapWgs84(position);\n  return [\n    longitudeToMercatorX(wrappedPos[0]),\n    latitudeToMercatorY(wrappedPos[1]),\n  ];\n}\n\n/**\n * Converts a mercator X (west-east axis in [0, 1]) to wgs84 longitude\n */\nfunction mercatorXToLongitude(x: number): number {\n  return x * 360 - 180;\n}\n\n/**\n * Converts a mercator Y (north-south axis in [0, 1]) to wgs84 latitude\n */\nfunction mercatorYToLatitude(y: number): number {\n  const y2 = 180 - y * 360;\n  return (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n}\n\n/**\n * Converts a web Mercator position where north-west is [0, 0] and south-east is [1, 1] into a wgs84\n */\nfunction mercatorToWgs84(position: Position): Position {\n  return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];\n}\n\n/**\n * Gives the distance in meters between two positions using the Haversine Formula.\n */\nfunction haversineDistanceWgs84(from: Position, to: Position): number {\n  const rad = Math.PI / 180;\n  const lat1 = from[1] * rad;\n  const lat2 = to[1] * rad;\n  const a =\n    Math.sin(lat1) * Math.sin(lat2) +\n    Math.cos(lat1) * Math.cos(lat2) * Math.cos((to[0] - from[0]) * rad);\n\n  const maxMeters = EARTH_RADIUS * Math.acos(Math.min(a, 1));\n  return maxMeters;\n}\n\n/**\n * Compute the cumulated distance for each position of an array of positions.\n * For I positions, there are I-1 distance, hence the distance at i corresponds\n * to the distance from the (i-1)th position to ith\n */\nfunction haversineCumulatedDistanceWgs84(positions: Position[]): number[] {\n  const cumulatedDistance = Array(positions.length);\n  cumulatedDistance[0] = 0;\n  const l = cumulatedDistance.length;\n\n  for (let i = 1; i < l; i++) {\n    cumulatedDistance[i] =\n      haversineDistanceWgs84(positions[i - 1], positions[i]) +\n      cumulatedDistance[i - 1];\n  }\n  return cumulatedDistance;\n}\n\n/**\n * Returns a position that has longitude in [-180, 180]\n */\nfunction wrapWgs84(position: Position): Position {\n  const lng = position[0];\n  const lat = position[1];\n\n  const d = 360;\n  const w = ((((lng + 180) % d) + d) % d) - 180;\n  const wrapLong = w === -180 ? 180 : w;\n\n  return [wrapLong, lat];\n}\n\n/*\n * The circumference at a line of latitude in meters.\n */\nexport function circumferenceAtLatitude(latitude: number) {\n  return EARTH_CIRCUMFERENCE * Math.cos((latitude * Math.PI) / 180);\n}\n\n/**\n * From a given mercator coordinate and a zoom level, computes the tile index\n */\nfunction mercatorToTileIndex(\n  /**\n   * Mercator coordinates (north-west is [0, 0], sourth-east is [1, 1])\n   */\n  position: Position,\n  /**\n   * Zoom level\n   */\n  zoom: number,\n  /**\n   * Returns integer tile indices if `true` or floating-point values if `false`\n   */\n  strict: boolean = true,\n): Position {\n  const numberOfTilePerAxis = 2 ** zoom;\n\n  const fIndex: Position = [\n    position[0] * numberOfTilePerAxis,\n    position[1] * numberOfTilePerAxis,\n  ];\n\n  return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;\n}\n\n/**\n * From a given wgs84 coordinate and a zoom level, computes the tile index\n */\nfunction wgs84ToTileIndex(\n  /**\n   * Wgs84 coordinates\n   */\n  position: Position,\n  /**\n   * Zoom level\n   */\n  zoom: number,\n  /**\n   * Returns integer tile indices if `true` or floating-point values if `false`\n   */\n  strict: boolean = true,\n): Position {\n  const merc = wgs84ToMercator(position);\n  return mercatorToTileIndex(merc, zoom, strict);\n}\n\n/**\n * Converts a degree angle into a radian angle\n */\nfunction toRadians(degrees: number): number {\n  return (degrees * Math.PI) / 180;\n}\n\n/**\n * Converts a radian angle to a degree angle\n */\nfunction toDegrees(radians: number): number {\n  return (radians * 180) / Math.PI;\n}\n\n/**\n * Compute an intermediate point between two reference points using the Haversine formula.\n * If ratio is `0`, the returned position is pos1.\n * If ratio is `1`, the returned position is pos2.\n * If ratio is `0.5`, the returned position is halfway pos1 pos2 in distance.\n */\nfunction haversineIntermediateWgs84(\n  pos1: Position,\n  pos2: Position,\n  ratio: number,\n): Position {\n  const d = haversineDistanceWgs84(pos1, pos2);\n  const 1 = toRadians(pos1[0]);\n  const 1 = toRadians(pos1[1]);\n  const 2 = toRadians(pos2[0]);\n  const 2 = toRadians(pos2[1]);\n\n  const  = d / EARTH_RADIUS; // Angular distance in radians\n  const a = Math.sin((1 - ratio) * ) / Math.sin();\n  const b = Math.sin(ratio * ) / Math.sin();\n  const x = a * Math.cos(1) * Math.cos(1) + b * Math.cos(2) * Math.cos(2);\n  const y = a * Math.cos(1) * Math.sin(1) + b * Math.cos(2) * Math.sin(2);\n  const z = a * Math.sin(1) + b * Math.sin(2);\n\n  const 3 = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const 3 = Math.atan2(y, x);\n\n  return [toDegrees(3), toDegrees(3)];\n}\n\nexport const math = {\n  EARTH_RADIUS,\n  EARTH_CIRCUMFERENCE,\n  longitudeToMercatorX,\n  latitudeToMercatorY,\n  wgs84ToMercator,\n  mercatorXToLongitude,\n  mercatorYToLatitude,\n  mercatorToWgs84,\n  haversineDistanceWgs84,\n  wrapWgs84,\n  circumferenceAtLatitude,\n  mercatorToTileIndex,\n  wgs84ToTileIndex,\n  toRadians,\n  toDegrees,\n  haversineIntermediateWgs84,\n  haversineCumulatedDistanceWgs84,\n};\n","import QuickLRU from \"quick-lru\";\nimport { config } from \"./config\";\n\n/**\n * Informations about an image\n */\nexport type PixelData = {\n  /**\n   * The array of pixels as RGBRGB or RGBARGBA in a row-major order\n   */\n  pixels: Uint8ClampedArray | Uint8Array;\n  /**\n   * Width of the image in number of pixels\n   */\n  width: number;\n  /**\n   * Height of the image in number of pixels\n   */\n  height: number;\n  /**\n   * Number of components per pixel (3 if image is RGB, 4 if image is RGBA)\n   */\n  components: number;\n};\n\n/**\n * Type for the function that decodes an image file ArrayBuffer into valid pixel data\n */\nexport type BufferToPixelDataFunction = (ArrayBuffer) => Promise<PixelData>;\n\n/**\n * Main properties necessary from a TileJSON\n */\nexport type TileJSON = {\n  scale: string;\n  format: string;\n  maxzoom: number;\n  minzoom: number;\n  profile: string;\n  description: string;\n  attribution: string;\n  bounds: [number, number, number, number];\n  center: [number, number, number];\n\n  /**\n   * TileJSON version\n   */\n  tilejson: string;\n  name: string;\n  crs: string;\n  crs_wkt: string;\n  extent: [number, number, number, number];\n  tiles: string[];\n};\n\n// The LRU cache for storing tile PixelData\nlet tileCache = null;\n\n/**\n * Singleton-like function to access the tile cache\n */\nexport function getTileCache(): QuickLRU<string, PixelData> {\n  if (!tileCache) {\n    tileCache = new QuickLRU({ maxSize: config.tileCacheSize });\n  }\n  return tileCache;\n}\n\n/**\n * Browser function to decode an image file buffer into valid pixel data\n */\nexport async function bufferToPixelDataBrowser(\n  buff: ArrayBuffer,\n): Promise<PixelData> {\n  const blob = new Blob([buff]);\n  const imageBitmap = await createImageBitmap(blob);\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = imageBitmap.width;\n  canvas.height = imageBitmap.height;\n  ctx.drawImage(imageBitmap, 0, 0);\n\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  return {\n    pixels: imageData.data,\n    width: canvas.width,\n    height: canvas.height,\n    components: imageData.data.length / (canvas.width * canvas.height),\n  };\n}\n\nexport function getBufferToPixelDataParser(): BufferToPixelDataFunction {\n  if (config.bufferToPixelData) {\n    return config.bufferToPixelData;\n  }\n\n  if (typeof window !== \"undefined\") {\n    return bufferToPixelDataBrowser;\n  }\n\n  throw new Error(\n    \"An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`\",\n  );\n}\n","import { LineString, MultiLineString, Position } from \"geojson\";\n\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\nimport { math } from \"./math\";\nimport {\n  TileJSON,\n  getBufferToPixelDataParser,\n  getTileCache,\n} from \"../tiledecoding\";\n\nconst terrainTileJsonURL = \"tiles/terrain-rgb-v2/tiles.json\";\nlet terrainTileJson: TileJSON = null;\n\nexport type ElevationAtOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Zoom level to use for the terrain RGB tileset.\n   * If not provided, the highest zoom level will be used\n   */\n  zoom?: number;\n};\n\n/**\n * Options for batch elevation lookup\n */\nexport type ElevationBatchOptions = ElevationAtOptions & {\n  /**\n   * If provided, a median kernel of the given size will smooth the elevation\n   * to reduce very small local variations\n   */\n  smoothingKernelSize?: number;\n};\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\nasync function fetchTerrainTileJson(apiKey: string): Promise<TileJSON> {\n  const endpoint = new URL(terrainTileJsonURL, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n  if (res.ok) {\n    terrainTileJson = (await res.json()) as TileJSON;\n    return terrainTileJson;\n  } else {\n    if (!res.ok) {\n      throw new ServiceError(res, customMessages[res.status] ?? \"\");\n    }\n  }\n}\n\n/**\n * Get the elevation at a given position.\n * The returned position is of form [longitude, latitude, altitude]\n */\nasync function at(\n  /**\n   * Wgs84 position as [longitude, latitude]\n   */\n  position: Position,\n  /**\n   * Options\n   */\n  options: ElevationAtOptions = {},\n): Promise<Position> {\n  const apiKey = options.apiKey ?? config.apiKey;\n\n  if (!terrainTileJson) {\n    await fetchTerrainTileJson(apiKey);\n  }\n\n  const maxZoom = terrainTileJson.maxzoom;\n  let zoom = ~~(options.zoom ?? maxZoom);\n  if (zoom > maxZoom || zoom < 0) {\n    zoom = maxZoom;\n  }\n  const tileIndex = math.wgs84ToTileIndex(position, zoom, false);\n\n  const tileX = ~~tileIndex[0];\n  const tileY = ~~tileIndex[1];\n\n  if (!terrainTileJson.tiles.length) {\n    throw new Error(\"Terrain tileJSON tile list is empty.\");\n  }\n\n  const tileID = `terrain_${zoom.toString()}_${tileX.toString()}_${tileY.toString()}`;\n  let tilePixelData;\n\n  const cache = getTileCache();\n\n  if (cache.has(tileID)) {\n    tilePixelData = cache.get(tileID);\n  } else {\n    const tileURL = terrainTileJson.tiles[0]\n      .replace(\"{x}\", tileX.toString())\n      .replace(\"{y}\", tileY.toString())\n      .replace(\"{z}\", zoom.toString());\n\n    const tileRes = await callFetch(tileURL);\n\n    if (!tileRes.ok) {\n      throw new ServiceError(tileRes, customMessages[tileRes.status] ?? \"\");\n    }\n\n    const tileBuff = await tileRes.arrayBuffer();\n    const tileParser = getBufferToPixelDataParser();\n    tilePixelData = await tileParser(tileBuff);\n    cache.set(tileID, tilePixelData);\n  }\n\n  const pixelX = ~~(tilePixelData.width * (tileIndex[0] % 1));\n  const pixelY = ~~(tilePixelData.height * (tileIndex[1] % 1));\n  const pixelDataIndex =\n    (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n  const R = tilePixelData.pixels[pixelDataIndex];\n  const G = tilePixelData.pixels[pixelDataIndex + 1];\n  const B = tilePixelData.pixels[pixelDataIndex + 2];\n  const elevation = -10000 + (R * 256 * 256 + G * 256 + B) * 0.1;\n\n  return [position[0], position[1], elevation];\n}\n\n/**\n * Perform a batch elevation request\n */\nasync function batch(\n  /**\n   * Wgs84 positions as [[lng0, lat0], [lng1, lat1], [lng2, lat2], ...]\n   */\n  positions: Position[],\n  /**\n   * Options\n   */\n  options: ElevationBatchOptions = {},\n): Promise<Position[]> {\n  const apiKey = options.apiKey ?? config.apiKey;\n\n  if (!terrainTileJson) {\n    await fetchTerrainTileJson(apiKey);\n  }\n\n  // Better throw about not bein able to parse tiles before fetching them\n  const tileParser = getBufferToPixelDataParser();\n  const tileURLSchema = terrainTileJson.tiles[0];\n  const cache = getTileCache();\n\n  const maxZoom = terrainTileJson.maxzoom;\n  let zoom = ~~(options.zoom ?? maxZoom);\n  if (zoom > maxZoom || zoom < 0) {\n    zoom = maxZoom;\n  }\n  const tileIndicesFloats = positions.map((position) =>\n    math.wgs84ToTileIndex(position, zoom, false),\n  );\n  const tileIndicesInteger = tileIndicesFloats.map((index) => [\n    ~~index[0],\n    ~~index[1],\n  ]);\n  const tileIDs = tileIndicesInteger.map(\n    (index) =>\n      `terrain_${zoom.toString()}_${index[0].toString()}_${index[1].toString()}`,\n  );\n\n  // unique tiles to fetch (excluding those already in cache and the doublons)\n  const uniqueTilesToFetch = Array.from(\n    new Set(tileIDs.filter((tileID) => !cache.has(tileID))),\n  ).map((tileID) => tileID.split(\"_\").slice(1));\n  const tileURLs = uniqueTilesToFetch.map((zxy) =>\n    tileURLSchema\n      .replace(\"{x}\", zxy[1].toString())\n      .replace(\"{y}\", zxy[2].toString())\n      .replace(\"{z}\", zxy[0].toString()),\n  );\n  const promisesFetchTiles = tileURLs.map((url) => callFetch(url));\n  const resTiles = await Promise.allSettled(promisesFetchTiles);\n  const fulfilledRes = resTiles\n    .map((el: PromiseSettledResult<Response>) =>\n      el.status === \"fulfilled\" ? el.value : null,\n    )\n    .filter((res) => res);\n  const fulfilledRButNotOkRes = fulfilledRes.filter((res) => !res.ok);\n\n  if (fulfilledRes.length !== promisesFetchTiles.length) {\n    throw new Error(\"Some tiles could not be fetched.\");\n  }\n\n  if (fulfilledRButNotOkRes.length) {\n    throw new ServiceError(\n      fulfilledRButNotOkRes[0],\n      customMessages[fulfilledRButNotOkRes[0].status] ?? \"\",\n    );\n  }\n\n  const tileArrayBuffers = await Promise.all(\n    fulfilledRes.map((res) => res.arrayBuffer()),\n  );\n\n  // It is possible that the tile is missing\n  if (!tileArrayBuffers.every((buff) => buff.byteLength > 0)) {\n    throw new Error(\"Some tiles are not available.\");\n  }\n\n  const tilePixelDatas = await Promise.all(\n    tileArrayBuffers.map((buff) => tileParser(buff)),\n  );\n\n  // Adding to cache\n  tilePixelDatas.forEach((tilePixelData, i) => {\n    const zxy = uniqueTilesToFetch[i];\n    const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;\n    cache.set(tileID, tilePixelData);\n  });\n\n  const elevatedPositions = positions.map((position, i) => {\n    const tileID = tileIDs[i];\n    const tileIndexFloat = tileIndicesFloats[i];\n    const tilePixelData = cache.get(tileID);\n\n    // const pixelX = ~~(tilePixelData.width * (tileIndexFloat[0] % 1));\n    // const pixelY = ~~(tilePixelData.height * (tileIndexFloat[1] % 1));\n\n    const pixelX = Math.min(\n      Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)),\n      tilePixelData.width - 1,\n    );\n    const pixelY = Math.min(\n      Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)),\n      tilePixelData.height - 1,\n    );\n\n    const pixelDataIndex =\n      (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n    const R = tilePixelData.pixels[pixelDataIndex];\n    const G = tilePixelData.pixels[pixelDataIndex + 1];\n    const B = tilePixelData.pixels[pixelDataIndex + 2];\n    const elevation = -10000 + (R * 256 * 256 + G * 256 + B) * 0.1;\n\n    return [position[0], position[1], ~~(elevation * 1000) / 1000];\n  });\n\n  // Smoothing\n  if (options.smoothingKernelSize) {\n    // make sure the kernel is of an odd size\n    const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;\n    const elevations: number[] = elevatedPositions.map((pos) => pos[2]);\n    const kernelSpan = ~~(kernelSize / 2);\n\n    for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {\n      let sum = 0;\n      for (let j = 0; j < kernelSize; j += 1) {\n        const elev = elevations[i - kernelSpan + j];\n        sum += elev;\n      }\n      sum /= kernelSize;\n      elevatedPositions[i][2] = sum;\n    }\n  }\n\n  return elevatedPositions;\n}\n\n/**\n * Creates a clone of a GeoJSON LineString (deep copy with structuredClone) that contains the computed elevation\n * as the third element of each position array ([lng, lat, alt])\n */\nasync function fromLineString(\n  /**\n   * A GeoJSON LineStriung feature\n   */\n  ls: LineString,\n  /**\n   * Options\n   */\n  options: ElevationBatchOptions = {},\n): Promise<LineString> {\n  if (ls.type !== \"LineString\") {\n    throw new Error(\"The provided object is not a GeoJSON LineString\");\n  }\n\n  const clone = structuredClone(ls) as LineString;\n  const elevatedPositions = await batch(clone.coordinates, options);\n  clone.coordinates = elevatedPositions;\n\n  return clone;\n}\n\n/**\n * Creates a clone of a MultiLineString (deep copy with structuredClone) that contains the computed elevation\n * as the third element of each position array ([lng, lat, alt])\n */\nasync function fromMultiLineString(\n  /**\n   * A GeoJSON LineStriung feature\n   */\n  ls: MultiLineString,\n  /**\n   * Options\n   */\n  options: ElevationBatchOptions = {},\n): Promise<MultiLineString> {\n  if (ls.type !== \"MultiLineString\") {\n    throw new Error(\"The provided object is not a GeoJSON MultiLineString\");\n  }\n\n  const clone = structuredClone(ls) as MultiLineString;\n  const multiLengths = clone.coordinates.map((poss) => poss.length);\n\n  // This is equivalent to a batch of batch, so we makes the multilinestring a unique\n  // line string to prevent batch to fetch multiple times the same tile\n  const flattenPositions = clone.coordinates.flat();\n  const flattenPositionsElevated = await batch(flattenPositions, options);\n\n  // And then chopping back into a multi line string\n  const result: Position[][] = [];\n  let index = 0;\n  for (const length of multiLengths) {\n    result.push(flattenPositionsElevated.slice(index, index + length));\n    index += length;\n  }\n\n  clone.coordinates = result;\n  return clone;\n}\n\nexport const elevation = {\n  at,\n  batch,\n  fromLineString,\n  fromMultiLineString,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}